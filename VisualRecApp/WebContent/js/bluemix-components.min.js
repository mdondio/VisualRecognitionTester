(function (exports) {
'use strict';

function listener(event) {
  var element = event.target;
  if (element.tagName === 'INPUT' && element.type === 'checkbox' && element.hasAttribute('checked') !== element.checked) {
    if (element.checked) {
      element.setAttribute('checked', '');
    } else {
      element.removeAttribute('checked');
    }
  }
}

/**
 * Watches for change in checkbox in the given document and force changing `checked` attribute
 * so that DOM mutation observer in {@link https://www.npmjs.com/package/svgxuse svgxuse} is triggered.
 * @param {Document} [doc=document] The document object to watch for.
 * @returns {Handle} The handle to release the event listener.
 */
function initCheckbox() {
  var doc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;

  doc.removeEventListener('change', listener); // In case this function has been called earlier
  doc.addEventListener('change', listener);
  return {
    release: function release() {
      doc.removeEventListener('change', listener);
      return null;
    }
  };
}

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _toConsumableArray$1(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/**
 * @param {Array} a An array.
 * @returns {Array} The flattened version of the given array.
 */
function flatten(a) {
  return a.reduce(function (result, item) {
    if (Array.isArray(item)) {
      result.push.apply(result, _toConsumableArray$1(flatten(item)));
    } else {
      result.push(item);
    }
    return result;
  }, []);
}

/**
 * An interface for defining mix-in classes. Used with {@link mixin}.
 * @function mixinfn
 * @param {Class} ToMix The class to mix.
 * @returns {Class} The class mixed-in with the given ToMix class.
 */

/**
 * @function mixin
 * @param {...mixinfn} mixinfns The functions generating mix-ins.
 * @returns {Class} The class generated with the given mix-ins.
 */
function mixin() {
  for (var _len = arguments.length, mixinfns = Array(_len), _key = 0; _key < _len; _key++) {
    mixinfns[_key] = arguments[_key];
  }

  return flatten(mixinfns).reduce(function (Class, mixinfn) {
    return mixinfn(Class);
  }, function () {
    function _class() {
      _classCallCheck$1(this, _class);
    }

    return _class;
  }());
}

var _createClass$1 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$1(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var createComponent = function (ToMix) {
  var CreateComponent = function (_ToMix) {
    _inherits$1(CreateComponent, _ToMix);

    /**
     * Mix-in class to manage lifecycle of component.
     * The constructor sets up this component's effective options,
     * and registers this component't instance associated to an element.
     * @implements Handle
     * @param {HTMLElement} element The element working as this component.
     * @param {Object} [options] The component options.
     */
    function CreateComponent(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      _classCallCheck$2(this, CreateComponent);

      var _this = _possibleConstructorReturn$1(this, (CreateComponent.__proto__ || Object.getPrototypeOf(CreateComponent)).call(this, element, options));

      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        throw new TypeError('DOM element should be given to initialize this widget.');
      }

      /**
       * The element the component is of.
       * @type {Element}
       */
      _this.element = element;

      /**
       * The component instances managed by this component.
       * Releasing this component also releases the components in `this.children`.
       * @type {Component[]}
       */
      _this.children = [];

      /**
       * The component options.
       * @type {Object}
       */
      _this.options = Object.assign(Object.create(_this.constructor.options), options);

      _this.constructor.components.set(_this.element, _this);
      return _this;
    }

    /**
     * Instantiates this component of the given element.
     * @param {HTMLElement} element The element.
     */


    _createClass$1(CreateComponent, [{
      key: 'release',


      /**
       * Releases this component's instance from the associated element.
       */
      value: function release() {
        for (var child = this.children.pop(); child; child = this.children.pop()) {
          child.release();
        }
        this.constructor.components.delete(this.element);
        return null;
      }
    }], [{
      key: 'create',
      value: function create(element, options) {
        return this.components.get(element) || new this(element, options);
      }
    }]);

    return CreateComponent;
  }(ToMix);

  return CreateComponent;
};

var _createClass$2 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$2(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$2(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var initComponentBySearch = function (ToMix) {
  /**
   * Mix-in class to instantiate components by searching for their root elements.
   * @class InitComponentBySearch
   */
  var InitComponentBySearch = function (_ToMix) {
    _inherits$2(InitComponentBySearch, _ToMix);

    function InitComponentBySearch() {
      _classCallCheck$3(this, InitComponentBySearch);

      return _possibleConstructorReturn$2(this, (InitComponentBySearch.__proto__ || Object.getPrototypeOf(InitComponentBySearch)).apply(this, arguments));
    }

    _createClass$2(InitComponentBySearch, null, [{
      key: 'init',

      /**
       * Instantiates component in the given node.
       * If the given element indicates that it's an component of this class, instantiates it.
       * Otherwise, instantiates components by searching for components in the given node.
       * @param {Node} target The DOM node to instantiate components in. Should be a document or an element.
       * @param {Object} [options] The component options.
       * @param {boolean} [options.selectorInit] The CSS selector to find components.
       */
      value: function init() {
        var _this2 = this;

        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var effectiveOptions = Object.assign(Object.create(this.options), options);
        if (target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new Error('DOM document or DOM element should be given to search for and initialize this widget.');
        }
        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options);
        } else {
          [].concat(_toConsumableArray$2(target.querySelectorAll(effectiveOptions.selectorInit))).forEach(function (element) {
            return _this2.create(element, options);
          });
        }
      }
    }]);

    return InitComponentBySearch;
  }(ToMix);

  return InitComponentBySearch;
};

var _createClass$3 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$3(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$3(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var eventedState = function (ToMix) {
  /**
   * Mix-in class to manage events associated with states.
   * @class EventedState
   */
  var EventedState = function (_ToMix) {
    _inherits$3(EventedState, _ToMix);

    function EventedState() {
      _classCallCheck$4(this, EventedState);

      return _possibleConstructorReturn$3(this, (EventedState.__proto__ || Object.getPrototypeOf(EventedState)).apply(this, arguments));
    }

    _createClass$3(EventedState, [{
      key: '_changeState',

      /**
       * The internal implementation for {@link EventedState#changeState `.changeState()`}, performing actual change in state.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {Object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} callback The callback called once changing state is finished or is canceled.
       * @private
       */
      value: function _changeState() {
        throw new Error('_changeState() should be overriden to perform actual change in state.');
      }

      /**
       * Changes the state of this component.
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {Object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @param {EventedState~changeStateCallback} [callback] The callback called once changing state is finished or is canceled.
       */

    }, {
      key: 'changeState',
      value: function changeState() {
        var _this2 = this;

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var state = typeof args[0] === 'string' ? args.shift() : undefined;
        var detail = Object(args[0]) === args[0] && typeof args[0] !== 'function' ? args.shift() : undefined;
        var callback = typeof args[0] === 'function' ? args.shift() : undefined;

        if (typeof this.shouldStateBeChanged === 'function' && !this.shouldStateBeChanged(state, detail)) {
          if (callback) {
            callback(null, true);
          }
          return;
        }

        var data = {
          group: detail && detail.group,
          state: state
        };

        var eventNameSuffix = [data.group, state].filter(Boolean).join('-').split('-') // Group or state may contain hyphen
        .map(function (item) {
          return item[0].toUpperCase() + item.substr(1);
        }).join('');

        var eventStart = new CustomEvent(this.options['eventBefore' + eventNameSuffix], {
          bubbles: true,
          cancelable: true,
          detail: detail
        });

        var fireOnNode = detail && detail.delegatorNode || this.element;
        var canceled = !fireOnNode.dispatchEvent(eventStart);

        if (canceled) {
          if (callback) {
            var error = new Error('Changing state (' + JSON.stringify(data) + ') has been canceled.');
            error.canceled = true;
            callback(error);
          }
        } else {
          var changeStateArgs = [state, detail].filter(Boolean);
          this._changeState.apply(this, _toConsumableArray$3(changeStateArgs).concat([function () {
            fireOnNode.dispatchEvent(new CustomEvent(_this2.options['eventAfter' + eventNameSuffix], {
              bubbles: true,
              cancelable: true,
              detail: detail
            }));
            if (callback) {
              callback();
            }
          }]));
        }
      }

      /**
       * Tests if change in state should happen or not.
       * Classes inheriting {@link EventedState `EventedState`} should override this function.
       * @function EventedState#shouldStateBeChanged
       * @param {string} [state] The new state. Can be an omitted, which means toggling.
       * @param {Object} [detail]
       *   The object that should be put to event details that is fired before/after changing state.
       *   Can have a `group` property, which specifies what state to be changed.
       * @returns {boolean}
       *   `false` if change in state shouldn't happen, e.g. when the given new state is the same as the current one.
       */

    }]);

    return EventedState;
  }(ToMix);

  /**
   * The callback called once changing state is finished or is canceled.
   * @callback EventedState~changeStateCallback
   * @param {Error} error
   *   An error object with `true` in its `canceled` property if changing state is canceled.
   *   Cancellation happens if the handler of a custom event, that is fired before changing state happens,
   *   calls `.preventDefault()` against the event.
   * @param {boolean} keptState
   *   `true` if the call to {@link EventedState#changeState `.changeState()`} didn't cause actual change in state.
   */

  return EventedState;
};

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FileUploader = function (_mixin) {
  _inherits(FileUploader, _mixin);

  /**
   * File uploader.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends eventedState
   * @param {HTMLElement} element The element working as a file uploader.
   * @param {Object} [options] The component options. See static options.
   */
  function FileUploader(element) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, FileUploader);

    var _this = _possibleConstructorReturn(this, (FileUploader.__proto__ || Object.getPrototypeOf(FileUploader)).call(this, element, options));

    _this._changeState = function (state, detail, callback) {
      if (state === 'delete-filename-fileuploader') {
        _this.container.removeChild(detail.filenameElement);
      }
      callback();
    };

    _this.input = _this.element.querySelector(_this.options.selectorInput);
    _this.container = _this.element.querySelector(_this.options.selectorContainer);

    if (!_this.input) {
      throw new Error('Cannot find the file input box.');
    }

    if (!_this.container) {
      throw new Error('Cannot find the file names container.');
    }

    _this.inputId = _this.input.getAttribute('id');
    _this.input.addEventListener('change', function () {
      return _this._displayFilenames();
    });
    return _this;
  }

  _createClass(FileUploader, [{
    key: '_filenamesHTML',
    value: function _filenamesHTML(name, id) {
      return '<span class="bx--file__selected-file">\n      <p class="bx--file-filename">' + name + '</p>\n      <span data-for="' + id + '" class="bx--file__state-container"></span>\n    </span>';
    }
  }, {
    key: '_uploadHTML',
    value: function _uploadHTML() {
      return '\n      <div data-loading class="bx--loading">\n        <svg class="bx--loading__svg" viewBox="-42 -42 84 84">\n          <circle cx="0" cy="0" r="37.5" />\n        </svg>\n      </div>';
    }
  }, {
    key: '_closeButtonHTML',
    value: function _closeButtonHTML() {
      return '\n      <svg class="bx--file-close" tabindex="0" viewBox="0 0 16 16" fill-rule="evenodd" width="16" height="16">\n        <path d="M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zm3.5 10.1l-1.4 1.4L8\n          9.4l-2.1 2.1-1.4-1.4L6.6 8 4.5 5.9l1.4-1.4L8 6.6l2.1-2.1 1.4 1.4L9.4 8l2.1 2.1z" />\n      </svg>';
    }
  }, {
    key: '_checkmarkHTML',
    value: function _checkmarkHTML() {
      return '\n      <svg class="bx--file-complete" viewBox="0 0 16 16" fill-rule="evenodd" width="16" height="16">\n       <path d="M8 0C3.6 0 0 3.6 0 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6.7 11.5L3.4 8.1l1.4-1.4 1.9 1.9 4.1-4.1 1.4 1.4-5.5 5.6z"/>\n      </svg>';
    }
  }, {
    key: '_getStateContainers',
    value: function _getStateContainers() {
      var stateContainers = [].concat(_toConsumableArray(this.element.querySelectorAll('[data-for=' + this.inputId + ']')));

      if (stateContainers.length === 0) {
        throw new TypeError('State container elements not found; invoke _displayFilenames() first');
      }

      if (stateContainers[0].dataset.for !== this.inputId) {
        throw new TypeError('File input id must equal [data-for] attribute');
      }

      return stateContainers;
    }

    /**
     * Inject selected files into DOM. Invoked on change event.
     */

  }, {
    key: '_displayFilenames',
    value: function _displayFilenames() {
      var _this2 = this;

      var container = this.element.querySelector(this.options.selectorContainer);
      var HTMLString = [].concat(_toConsumableArray(this.input.files)).map(function (file) {
        return _this2._filenamesHTML(file.name, _this2.inputId);
      }).join('');

      container.insertAdjacentHTML('afterbegin', HTMLString);
    }
  }, {
    key: '_removeState',
    value: function _removeState(element) {
      if (!element || element.nodeType !== Node.ELEMENT_NODE) {
        throw new TypeError('DOM element should be given to initialize this widget.');
      }
      while (element.firstChild) {
        element.removeChild(element.firstChild);
      }
    }
  }, {
    key: '_handleStateChange',
    value: function _handleStateChange(elements, selectIndex, html) {
      var _this3 = this;

      if (selectIndex === undefined) {
        elements.forEach(function (el) {
          _this3._removeState(el);
          el.insertAdjacentHTML('beforeend', html);
        });
      } else {
        elements.forEach(function (el, index) {
          if (index === selectIndex) {
            _this3._removeState(el);
            el.insertAdjacentHTML('beforeend', html);
          }
        });
      }
    }
  }, {
    key: 'setState',
    value: function setState(state, selectIndex) {
      var _this4 = this;

      var stateContainers = this._getStateContainers();

      if (state === 'edit') {
        this._handleStateChange(stateContainers, selectIndex, this._closeButtonHTML());
        stateContainers.forEach(function (el) {
          el.addEventListener('click', function (evt) {
            var detail = {
              initialEvt: evt,
              filenameElement: evt.currentTarget.parentNode
            };
            _this4._changeState('delete-filename-fileuploader', detail);
          });
        });
      }

      if (state === 'upload') {
        this._handleStateChange(stateContainers, selectIndex, this._uploadHTML());
      }

      if (state === 'complete') {
        this._handleStateChange(stateContainers, selectIndex, this._checkmarkHTML());
      }
    }

    /**
     * The map associating DOM element and file uploader instance.
     * @member FileUploader.components
     * @type {WeakMap}
     */

  }]);

  return FileUploader;
}(mixin(createComponent, initComponentBySearch, eventedState));

FileUploader.components = new WeakMap();
FileUploader.options = {
  selectorInit: '[data-file]',
  selectorInput: 'input[type="file"].bx--file-input',
  selectorContainer: '[data-file-container]',
  selectorCloseButton: '.bx--file-close',
  eventBeforeDeleteFilenameFileuploader: 'fileuploader-before-delete-filename',
  eventAfterDeleteFilenameFileuploader: 'fileuploader-after-delete-filename'
};

function eventMatches(event, selector) {
  // <svg> in IE does not have `Element#msMatchesSelector()` (that should be copied to `Element#matches()` by a polyfill).
  // Also a weird behavior is seen in IE where DOM tree seems broken when `event.target` is on <svg>.
  // Therefore this function simply returns `undefined` when `event.target` is on <svg>.
  if (typeof event.target.matches === 'function') {
    if (event.target.matches(selector)) {
      // If event target itself matches the given selector, return it
      return event.target;
    } else if (event.target.matches(selector + ' *')) {
      // If event target is a child node of a DOM element that matches the given selector,
      // find the DOM element by going up the DOM tree
      for (var traverse = event.target; traverse && traverse !== event.currentTarget; traverse = traverse.parentNode) {
        if (traverse.matches(selector)) {
          return traverse;
        }
      }
    }
  }
  return undefined;
}

function on(element) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  element.addEventListener.apply(element, args);
  return {
    release: function release() {
      element.removeEventListener.apply(element, args);
      return null;
    }
  };
}

var _createClass$5 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$5(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var initComponentByEvent = function (ToMix) {
  /**
   * Mix-in class to instantiate components upon events.
   * @class InitComponentByEvent
   */
  var InitComponentByEvent = function (_ToMix) {
    _inherits$5(InitComponentByEvent, _ToMix);

    function InitComponentByEvent() {
      _classCallCheck$6(this, InitComponentByEvent);

      return _possibleConstructorReturn$5(this, (InitComponentByEvent.__proto__ || Object.getPrototypeOf(InitComponentByEvent)).apply(this, arguments));
    }

    _createClass$5(InitComponentByEvent, null, [{
      key: 'init',

      /**
       * Instantiates this component in the given element.
       * If the given element indicates that it's an component of this class, instantiates it.
       * Otherwise, instantiates this component by clicking on this component in the given node.
       * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
       * @param {Object} [options] The component options.
       * @param {string} [options.selectorInit] The CSS selector to find this component.
       * @returns {Handle} The handle to remove the event listener to handle clicking.
       */
      value: function init() {
        var _this2 = this;

        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var effectiveOptions = Object.assign(Object.create(this.options), options);
        if (target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new Error('DOM document or DOM element should be given to search for and initialize this widget.');
        }
        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options);
        } else {
          var handles = effectiveOptions.initEventNames.map(function (name) {
            return on(target, name, function (event) {
              var element = eventMatches(event, effectiveOptions.selectorInit);
              if (element && !_this2.components.has(element)) {
                var component = _this2.create(element, options);
                if (typeof component.createdByEvent === 'function') {
                  component.createdByEvent(event);
                }
              }
            });
          });
          return {
            release: function release() {
              for (var handle = handles.pop(); handle; handle = handles.pop()) {
                handle.release();
              }
            }
          };
        }
        return '';
      }
    }]);

    return InitComponentByEvent;
  }(ToMix);

  return InitComponentByEvent;
};

var _createClass$4 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$4(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FabButton = function (_mixin) {
  _inherits$4(FabButton, _mixin);

  /**
   * Floating action button.
   * @extends CreateComponent
   * @extends InitComponentByEvent
   * @param {HTMLElement} element The element working as a floting action button.
   */
  function FabButton(element) {
    _classCallCheck$5(this, FabButton);

    var _this = _possibleConstructorReturn$4(this, (FabButton.__proto__ || Object.getPrototypeOf(FabButton)).call(this, element));

    element.addEventListener('click', function (event) {
      _this.toggle(event);
    });
    return _this;
  }

  /**
   * A method called when this widget is created upon clicking.
   * @param {Event} event The event triggering the creation.
   */


  _createClass$4(FabButton, [{
    key: 'createdByEvent',
    value: function createdByEvent(event) {
      this.toggle(event);
    }

    /**
     * Toggles this floating action button.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: 'toggle',
    value: function toggle(event) {
      if (this.element.tagName === 'A') {
        event.preventDefault();
      }

      if (this.element.dataset.state === 'closed') {
        this.element.dataset.state = 'open';
      } else {
        this.element.dataset.state = 'closed';
      }
    }

    /**
     * Instantiates floating action button of the given element.
     * @param {HTMLElement} element The element.
     */

  }], [{
    key: 'create',
    value: function create(element) {
      return this.components.get(element) || new this(element);
    }

    /**
     * The map associating DOM element and floating action button instance.
     * @member FabButton.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode FabButton.create .create()}, or {@linkcode FabButton.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode FabButton.init .init()} works.
     * @member FabButton.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find floating action buttons.
     */

  }]);

  return FabButton;
}(mixin(createComponent, initComponentByEvent));

FabButton.components = new WeakMap();
FabButton.options = {
  selectorInit: '[data-fab]',
  initEventNames: ['click']
};

var _createClass$6 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$4(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$6(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ContentSwitcher = function (_mixin) {
  _inherits$6(ContentSwitcher, _mixin);

  /**
   * Set of content switcher buttons.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends EventedState
   * @param {HTMLElement} element The element working as a set of content switcher buttons.
   * @param {Object} [options] The component options.
   * @param {string} [options.selectorButton] The CSS selector to find switcher buttons.
   * @param {string} [options.selectorButtonSelected] The CSS selector to find the selected switcher button.
   * @param {string} [options.classActive] The CSS class for switcher button's selected state.
   * @param {string} [options.eventBeforeSelected]
   *   The name of the custom event fired before a switcher button is selected.
   *   Cancellation of this event stops selection of content switcher button.
   * @param {string} [options.eventAfterSelected] The name of the custom event fired after a switcher button is selected.
   */
  function ContentSwitcher(element, options) {
    _classCallCheck$7(this, ContentSwitcher);

    var _this = _possibleConstructorReturn$6(this, (ContentSwitcher.__proto__ || Object.getPrototypeOf(ContentSwitcher)).call(this, element, options));

    _this.element.addEventListener('click', function (event) {
      _this._handleClick(event);
    });
    return _this;
  }

  /**
   * Handles click on content switcher button set.
   * If the click is on a content switcher button, activates it.
   * @param {Event} event The event triggering this method.
   */


  _createClass$6(ContentSwitcher, [{
    key: '_handleClick',
    value: function _handleClick(event) {
      var button = eventMatches(event, this.options.selectorButton);

      if (button) {
        this.changeState({
          group: 'selected',
          item: button,
          launchingEvent: event
        });
      }
    }

    /**
     * Internal method of {@linkcode ContentSwitcher#setActive .setActive()}, to select a content switcher button.
     * @private
     * @param {Object} detail The detail of the event trigging this action.
     * @param {HTMLElement} detail.item The button to be selected.
     * @param {Function} callback Callback called when change in state completes.
     */

  }, {
    key: '_changeState',
    value: function _changeState(detail, callback) {
      var _this2 = this;

      var item = detail.item;
      // `options.selectorLink` is not defined in this class itself, code here primary is for inherited classes
      var itemLink = item.querySelector(this.options.selectorLink);
      if (itemLink) {
        [].concat(_toConsumableArray$4(this.element.querySelectorAll(this.options.selectorLink))).forEach(function (link) {
          if (link !== itemLink) {
            link.setAttribute('aria-selected', 'false');
          }
        });
        itemLink.setAttribute('aria-selected', 'true');
      }

      var selectorButtons = [].concat(_toConsumableArray$4(this.element.querySelectorAll(this.options.selectorButton)));

      selectorButtons.forEach(function (button) {
        if (button !== item) {
          button.classList.toggle(_this2.options.classActive, false);
          [].concat(_toConsumableArray$4(button.ownerDocument.querySelectorAll(button.dataset.target))).forEach(function (element) {
            return element.setAttribute('hidden', '');
          });
        }
      });

      item.classList.toggle(this.options.classActive, true);
      [].concat(_toConsumableArray$4(item.ownerDocument.querySelectorAll(item.dataset.target))).forEach(function (element) {
        return element.removeAttribute('hidden');
      });

      if (callback) {
        callback();
      }
    }

    /**
     * Selects a content switcher button.
     * If the selected button has `data-target` attribute, DOM elements it points to as a CSS selector will be shown.
     * DOM elements associated with unselected buttons in the same way will be hidden.
     * @param {HTMLElement} item The button to be selected.
     * @param {ChangeState~callback} callback The callback is called once selection is finished
     * or is canceled. Will only invoke callback if it's passed in.
     */

  }, {
    key: 'setActive',
    value: function setActive(item, callback) {
      this.changeState({
        group: 'selected',
        item: item
      }, function (error) {
        if (error) {
          if (callback) {
            callback(Object.assign(error, { item: item }));
          }
        } else if (callback) {
          callback(null, item);
        }
      });
    }

    /**
     * The map associating DOM element and content switcher set instance.
     * @member ContentSwitcher.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode ContentSwitcher.create .create()}, or {@linkcode ContentSwitcher.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode ContentSwitcher.init .init()} works.
     * @member ContentSwitcher.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find content switcher button set.
     * @property {string} [selectorButton] The CSS selector to find switcher buttons.
     * @property {string} [selectorButtonSelected] The CSS selector to find the selected switcher button.
     * @property {string} [classActive] The CSS class for switcher button's selected state.
     * @property {string} [eventBeforeSelected]
     *   The name of the custom event fired before a switcher button is selected.
     *   Cancellation of this event stops selection of content switcher button.
     * @property {string} [eventAfterSelected] The name of the custom event fired after a switcher button is selected.
     */

  }]);

  return ContentSwitcher;
}(mixin(createComponent, initComponentBySearch, eventedState));

ContentSwitcher.components = new WeakMap();
ContentSwitcher.options = {
  selectorInit: '[data-content-switcher]',
  selectorButton: 'input[type="radio"], .bx--content-switcher-btn',
  classActive: 'bx--content-switcher--selected',
  eventBeforeSelected: 'content-switcher-beingselected',
  eventAfterSelected: 'content-switcher-selected'
};

var _createClass$7 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray$5(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$7(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tab = function (_ContentSwitcher) {
  _inherits$7(Tab, _ContentSwitcher);

  /**
   * Container of tabs.
   * @extends ContentSwitcher
   * @param {HTMLElement} element The element working as a container of tabs.
   * @param {Object} [options] The component options.
   * @param {string} [options.selectorMenu] The CSS selector to find the drop down menu used in narrow mode.
   * @param {string} [options.selectorTrigger] The CSS selector to find the button to open the drop down menu used in narrow mode.
   * @param {string} [options.selectorTriggerText]
   *   The CSS selector to find the element used in narrow mode showing the selected tab item.
   * @param {string} [options.selectorButton] The CSS selector to find tab containers.
   * @param {string} [options.selectorButtonSelected] The CSS selector to find the selected tab.
   * @param {string} [options.selectorLink] The CSS selector to find the links in tabs.
   * @param {string} [options.classActive] The CSS class for tab's selected state.
   * @param {string} [options.classHidden] The CSS class for the drop down menu's hidden state used in narrow mode.
   * @param {string} [options.eventBeforeSelected]
   *   The name of the custom event fired before a tab is selected.
   *   Cancellation of this event stops selection of tab.
   * @param {string} [options.eventAfterSelected] The name of the custom event fired after a tab is selected.
   */
  function Tab(element, options) {
    _classCallCheck$8(this, Tab);

    var _this = _possibleConstructorReturn$7(this, (Tab.__proto__ || Object.getPrototypeOf(Tab)).call(this, element, options));

    _this.element.addEventListener('keydown', function (event) {
      _this._handleKeyDown(event);
    });

    var selected = _this.element.querySelector(_this.options.selectorButtonSelected);
    if (selected) {
      _this._updateTriggerText(selected);
    }
    return _this;
  }

  /**
   * Internal method of {@linkcode Tab#setActive .setActive()}, to select a tab item.
   * @private
   * @param {Object} detail The detail of the event trigging this action.
   * @param {HTMLElement} detail.item The tab item to be selected.
   * @param {Function} callback Callback called when change in state completes.
   */


  _createClass$7(Tab, [{
    key: '_changeState',
    value: function _changeState(detail, callback) {
      var _this2 = this;

      _get(Tab.prototype.__proto__ || Object.getPrototypeOf(Tab.prototype), '_changeState', this).call(this, detail, function (error) {
        for (var _len = arguments.length, data = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          data[_key - 1] = arguments[_key];
        }

        if (!error) {
          _this2._updateTriggerText(detail.item);
        }
        callback.apply(undefined, [error].concat(data));
      });
    }

    /**
     * Handles click on tab container.
     * * If the click is on a tab, activates it.
     * * If the click is on the button to open the drop down menu, does so.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: '_handleClick',
    value: function _handleClick(event) {
      _get(Tab.prototype.__proto__ || Object.getPrototypeOf(Tab.prototype), '_handleClick', this).call(this, event);
      var button = eventMatches(event, this.options.selectorButton);
      var trigger = eventMatches(event, this.options.selectorTrigger);
      if (button) {
        _get(Tab.prototype.__proto__ || Object.getPrototypeOf(Tab.prototype), '_handleClick', this).call(this, event);
        this._updateMenuState();
      }
      if (trigger) {
        this._updateMenuState();
      }
    }

    /**
     * Handles arrow keys on tab container.
     * * Left keys are used to go to previous tab.
     * * Right keys are used to go to next tab.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: '_handleKeyDown',
    value: function _handleKeyDown(event) {
      var _this3 = this;

      var triggerNode = this.element.querySelector(this.options.selectorTrigger);
      if (triggerNode && triggerNode.offsetParent) {
        if (event.which === 13) {
          this._updateMenuState();
        }
      }

      var direction = {
        37: this.constructor.NAVIGATE.BACKWARD,
        39: this.constructor.NAVIGATE.FORWARD
      }[event.which];

      if (direction) {
        var buttons = [].concat(_toConsumableArray$5(this.element.querySelectorAll(this.options.selectorButton)));
        var button = this.element.querySelector(this.options.selectorButtonSelected);
        var nextIndex = Math.max(buttons.indexOf(button) + direction, -1 /* For `button` not found in `buttons` */);
        var nextIndexLooped = nextIndex >= 0 && nextIndex < buttons.length ? nextIndex : nextIndex - Math.sign(nextIndex) * buttons.length;
        this.setActive(buttons[nextIndexLooped], function (error, item) {
          if (item) {
            var link = item.querySelector(_this3.options.selectorLink);
            if (link) {
              link.focus();
            }
          }
        });
        event.preventDefault();
      }
    }

    /**
     * Shows/hides the drop down menu used in narrow mode.
     */

  }, {
    key: '_updateMenuState',
    value: function _updateMenuState() {
      var menu = this.element.querySelector(this.options.selectorMenu);
      if (menu) {
        menu.classList.toggle(this.options.classHidden);
      }
    }

    /**
     * Updates the text indicating the currently selected tab item.
     * @param {HTMLElement} target The newly selected tab item.
     */

  }, {
    key: '_updateTriggerText',
    value: function _updateTriggerText(target) {
      var triggerText = this.element.querySelector(this.options.selectorTriggerText);
      if (triggerText) {
        triggerText.textContent = target.textContent;
      }
    }

    /**
     * The map associating DOM element and tab container instance.
     * @member Tab.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode ContentSwitcher.create .create()}, or {@linkcode Tab.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Tab.init .init()} works.
     * @member Tab.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find tab containers.
     * @property {string} [selectorMenu] The CSS selector to find the drop down menu used in narrow mode.
     * @property {string} [selectorTrigger] The CSS selector to find the button to open the drop down menu used in narrow mode.
     * @property {string} [selectorTriggerText]
     *   The CSS selector to find the element used in narrow mode showing the selected tab item.
     * @property {string} [selectorButton] The CSS selector to find tab containers.
     * @property {string} [selectorButtonSelected] The CSS selector to find the selected tab.
     * @property {string} [selectorLink] The CSS selector to find the links in tabs.
     * @property {string} [classActive] The CSS class for tab's selected state.
     * @property {string} [classHidden] The CSS class for the drop down menu's hidden state used in narrow mode.
     * @property {string} [eventBeforeSelected]
     *   The name of the custom event fired before a tab is selected.
     *   Cancellation of this event stops selection of tab.
     * @property {string} [eventAfterSelected] The name of the custom event fired after a tab is selected.
     */


    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member Tab.NAVIGATE
     * @type {Object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  return Tab;
}(ContentSwitcher);

Tab.components = new WeakMap();
Tab.options = Object.assign(Object.create(ContentSwitcher.options), {
  selectorInit: '[data-tabs]',
  selectorMenu: '.bx--tabs__nav',
  selectorTrigger: '.bx--tabs-trigger',
  selectorTriggerText: '.bx--tabs-trigger-text',
  selectorButton: '.bx--tabs__nav-item',
  selectorButtonSelected: '.bx--tabs__nav-item--selected',
  selectorLink: '.bx--tabs__nav-link',
  classActive: 'bx--tabs__nav-item--selected',
  classHidden: 'bx--tabs__nav--hidden',
  eventBeforeSelected: 'tab-beingselected',
  eventAfterSelected: 'tab-selected'
});
Tab.NAVIGATE = {
  BACKWARD: -1,
  FORWARD: 1
};

function getLaunchingDetails(evt) {
  if (!evt || typeof evt === 'function') {
    return {
      launchingElement: null,
      launchingEvent: null
    };
  }

  var launchingElement = evt.delegateTarget || evt.currentTarget || evt;
  var launchingEvent = evt.currentTarget && evt;

  if (launchingElement && !launchingElement.nodeType) {
    throw new TypeError('DOM Node should be given for launching element.');
  }

  if (launchingEvent && !launchingEvent.type) {
    throw new TypeError('DOM event should be given for launching event.');
  }

  return {
    launchingElement: launchingElement,
    launchingEvent: launchingEvent
  };
}

var _createClass$9 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$10(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$9(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function eventedShowHideState(ToMix) {
  /**
   * Mix-in class to launch a floating menu.
   * @class EventedShowHideState
   */
  var EventedShowHideState = function (_ToMix) {
    _inherits$9(EventedShowHideState, _ToMix);

    function EventedShowHideState() {
      _classCallCheck$10(this, EventedShowHideState);

      return _possibleConstructorReturn$9(this, (EventedShowHideState.__proto__ || Object.getPrototypeOf(EventedShowHideState)).apply(this, arguments));
    }

    _createClass$9(EventedShowHideState, [{
      key: 'show',

      /**
       */
      /**
       * Switch to 'shown' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */
      value: function show(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === 'function') {
          callback = evtOrElem; // eslint-disable-line no-param-reassign
        }
        this.changeState('shown', getLaunchingDetails(evtOrElem), callback);
      }

      /**
       * Switch to 'hidden' state.
       * @param [evtOrElem] The launching event or element.
       * @param {EventedState~changeStateCallback} [callback] The callback.
       */

    }, {
      key: 'hide',
      value: function hide(evtOrElem, callback) {
        if (!evtOrElem || typeof evtOrElem === 'function') {
          callback = evtOrElem; // eslint-disable-line no-param-reassign
        }
        this.changeState('hidden', getLaunchingDetails(evtOrElem), callback);
      }
    }]);

    return EventedShowHideState;
  }(ToMix);

  return EventedShowHideState;
}

var exports$1 = [eventedState, eventedShowHideState];

// mdn resize function

var optimizedResize = function optimizedResize() {
  var callbacks = [];
  var running = false;

  // run the actual callbacks
  function runCallbacks() {
    callbacks.forEach(function (callback) {
      callback();
    });

    running = false;
  }

  // fired on resize event
  function resize() {
    if (!running) {
      running = true;
      window.requestAnimationFrame(runCallbacks);
    }
  }

  // adds callback to loop
  function addCallback(callback) {
    if (callback) {
      var index = callbacks.indexOf(callback);
      if (index < 0) {
        callbacks.push(callback);
      }
    }
  }

  return {
    // public method to add additional callback
    add: function add(callback) {
      if (!callbacks.length) {
        window.addEventListener('resize', resize);
      }
      addCallback(callback);
      return {
        release: function release() {
          var index = callbacks.indexOf(callback);
          if (index >= 0) {
            callbacks.splice(index, 1);
          }
        }
      };
    }
  };
}();

var _createClass$10 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$2 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck$11(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$10(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$10(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FloatingMenu = function (_mixin) {
  _inherits$10(FloatingMenu, _mixin);

  /**
   * Floating menu.
   * @extends CreateComponent
   * @extends EventedShowHideState
   * @param {HTMLElement} element The element working as a modal dialog.
   * @param {Object} [options] The component options.
   * @param {string} [options.selectorContainer] The CSS selector to find the container to put this menu in.
   * @param {string} [options.attribDirection] The attribute name to specify menu placement direction (top/right/bottom/left).
   * @param {string} [options.classShown] The CSS class for shown state, for the menu.
   * @param {string} [options.classRefShown] The CSS class for shown state, for the trigger button.
   * @param {string} [options.eventBeforeShown]
   *   The name of the custom event fired before this menu is shown.
   *   Cancellation of this event stops hiding the menu.
   * @param {string} [options.eventAfterShown]
   *   The name of the custom event telling that menu is sure shown
   *   without being canceled by the event handler named by `eventBeforeShown` option (`floating-menu-beingshown`).
   * @param {string} [options.eventBeforeHidden]
   *   The name of the custom event fired before this menu is hidden.
   *   Cancellation of this event stops hiding the menu.
   * @param {string} [options.eventAfterHidden]
   *   The name of the custom event telling that menu is sure hidden
   *   without being canceled by the event handler named by `eventBeforeHidden` option (`floating-menu-beinghidden`).
   * @param {Element} [options.refNode] The launching element of the menu. Used for calculating the geometry of the menu.
   * @param {Object} [options.offset] The offset to adjust the geometry of the menu. Should have `top`/`left` properties.
   */
  function FloatingMenu(element, options) {
    _classCallCheck$11(this, FloatingMenu);

    var _this = _possibleConstructorReturn$10(this, (FloatingMenu.__proto__ || Object.getPrototypeOf(FloatingMenu)).call(this, element, options));

    var attribDirectionValue = _this.element.getAttribute(_this.options.attribDirection);
    if (!_this.options.direction) {
      _this.options.direction = attribDirectionValue || 'bottom';
    }
    if (!attribDirectionValue) {
      // Update attribute for styling
      _this.element.setAttribute(_this.options.attribDirection, _this.options.direction);
    }
    return _this;
  }

  /**
   * @private
   * @returns {Element} The element that this menu should be placed to.
   */


  _createClass$10(FloatingMenu, [{
    key: '_getContainer',
    value: function _getContainer() {
      var element = this.element;
      var body = element.ownerDocument.body;
      for (var traverse = element; traverse && traverse !== body; traverse = traverse.parentNode) {
        if (traverse.matches(this.options.selectorContainer)) {
          return traverse;
        }
      }
      return body;
    }

    /**
     * @private
     * @returns {Object} The menu position, with `top` and `left` properties.
     */

  }, {
    key: '_getPos',
    value: function _getPos() {
      var element = this.element;
      var _options = this.options,
          refNode = _options.refNode,
          offset = _options.offset,
          direction = _options.direction;


      if (!refNode) {
        throw new Error('Cannot find the refernce node for positioning floating menu.');
      }

      var scroll = refNode.ownerDocument.defaultView.pageYOffset;

      var _refNode$getBoundingC = refNode.getBoundingClientRect(),
          refLeft = _refNode$getBoundingC.left,
          refTop = _refNode$getBoundingC.top,
          refRight = _refNode$getBoundingC.right,
          refBottom = _refNode$getBoundingC.bottom;

      var _element$getBoundingC = element.getBoundingClientRect(),
          menuWidth = _element$getBoundingC.width,
          menuHeight = _element$getBoundingC.height;

      var refCenterHorizontal = (refLeft + refRight) / 2;
      var refCenterVertical = (refTop + refBottom) / 2;

      return {
        left: function left() {
          return {
            left: refLeft - menuWidth - offset.left,
            top: refCenterVertical - menuHeight / 2 + scroll + offset.top
          };
        },
        top: function top() {
          return {
            left: refCenterHorizontal - menuWidth / 2 + offset.left,
            top: refTop - menuHeight + scroll - offset.top
          };
        },
        right: function right() {
          return {
            left: refRight + offset.left,
            top: refCenterVertical - menuHeight / 2 + scroll + offset.top
          };
        },
        bottom: function bottom() {
          return {
            left: refCenterHorizontal - menuWidth / 2 + offset.left,
            top: refBottom + scroll + offset.top
          };
        }
      }[direction]();
    }

    /**
     * Sees if the computed style is what this floating menu expects.
     * @private
     */

  }, {
    key: '_testStyles',
    value: function _testStyles() {
      if (!this.options.debugStyle) {
        return;
      }
      var element = this.element;
      var computedStyle = element.ownerDocument.defaultView.getComputedStyle(element);
      var styles = {
        position: 'absolute',
        right: 'auto',
        margin: 0
      };
      Object.keys(styles).forEach(function (key) {
        var expected = typeof styles[key] === 'number' ? parseFloat(styles[key]) : styles[key];
        var actual = computedStyle.getPropertyValue(key);
        if (expected !== actual) {
          // eslint-disable-next-line no-console
          console.warn('Floating menu component expects ' + key + ': ' + styles[key] + ' style.');
        }
      });
    }

    /**
     * Places the menu.
     * @private
     */

  }, {
    key: '_place',
    value: function _place() {
      var element = this.element;

      var _getPos2 = this._getPos(),
          left = _getPos2.left,
          top = _getPos2.top;

      element.style.left = left + 'px';
      element.style.top = top + 'px';
      this._testStyles();
    }

    /**
     * @param {string} state The new state.
     * @returns {boolean} `true` of the current state is different from the given new state.
     */

  }, {
    key: 'shouldStateBeChanged',
    value: function shouldStateBeChanged(state) {
      return (state === 'shown' || state === 'hidden') && state !== (this.element.classList.contains(this.options.classShown) ? 'shown' : 'hidden');
    }

    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {Object} detail The detail of the event trigging this action.
     * @param {Function} callback Callback called when change in state completes.
     */

  }, {
    key: '_changeState',
    value: function _changeState(state, detail, callback) {
      var _this2 = this;

      var shown = state === 'shown';
      var _options2 = this.options,
          refNode = _options2.refNode,
          classShown = _options2.classShown,
          classRefShown = _options2.classRefShown;

      this.element.classList.toggle(classShown, shown);
      if (classRefShown) {
        refNode.classList.toggle(classRefShown, shown);
      }
      if (state === 'shown') {
        if (!this.hResize) {
          this.hResize = optimizedResize.add(function () {
            _this2._place();
          });
        }
        this._getContainer().appendChild(this.element);
        this._place();
      }
      if (state === 'hidden' && this.hResize) {
        this.hResize.release();
        this.hResize = null;
      }
      callback();
    }
  }, {
    key: 'release',
    value: function release() {
      if (this.hResize) {
        this.hResize.release();
        this.hResize = null;
      }
      _get$2(FloatingMenu.prototype.__proto__ || Object.getPrototypeOf(FloatingMenu.prototype), 'release', this).call(this);
    }
  }]);

  return FloatingMenu;
}(mixin(createComponent, exports$1));

FloatingMenu.options = {
  selectorContainer: '[data-floating-menu-container]',
  attribDirection: 'data-floating-menu-direction',
  classShown: '', // Should be provided from options arg in constructor
  classRefShown: '', // Should be provided from options arg in constructor
  eventBeforeShown: 'floating-menu-beingshown',
  eventAfterShown: 'floating-menu-shown',
  eventBeforeHidden: 'floating-menu-beinghidden',
  eventAfterHidden: 'floating-menu-hidden',
  refNode: null, // Should be provided from options arg in constructor
  offset: {
    left: 0,
    top: 0
  }
};
FloatingMenu.components = new WeakMap();

var _createClass$8 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$1 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$8(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var OverflowMenu = function (_mixin) {
  _inherits$8(OverflowMenu, _mixin);

  /**
   * Overflow menu.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a modal dialog.
   * @param {Object} [options] The component options.
   * @param {string} [options.selectorOptionMenu] The CSS selector to find the menu.
   * @param {string} [options.classShown] The CSS class for the shown state, for the trigger UI.
   * @param {string} [options.classMenuShown] The CSS class for the shown state, for the menu.
   * @param {string} [options.classMenuFlip] The CSS class for the flipped state of the menu.
   * @param {Object} [options.objMenuOffset] The offset locating the menu for the non-flipped state.
   * @param {Object} [options.objMenuOffsetFlip] The offset locating the menu for the flipped state.
   */
  function OverflowMenu(element, options) {
    _classCallCheck$9(this, OverflowMenu);

    /**
     * The handle to release click event listener on document object.
     * @member {Handle}
     */
    var _this = _possibleConstructorReturn$8(this, (OverflowMenu.__proto__ || Object.getPrototypeOf(OverflowMenu)).call(this, element, options));

    _this.hDocumentClick = on(_this.element.ownerDocument, 'click', function (event) {
      _this._handleDocumentClick(event);
    });

    /**
     * The handle to release keypress event listener on document object.
     * @member {Handle}
     */
    _this.hDocumentKeyPress = on(_this.element.ownerDocument, 'keypress', function (event) {
      _this._handleKeyPress(event);
    });
    return _this;
  }

  /**
   * Changes the shown/hidden state.
   * @param {string} state The new state.
   * @param {Object} detail The detail of the event trigging this action.
   * @param {Function} callback Callback called when change in state completes.
   */


  _createClass$8(OverflowMenu, [{
    key: 'changeState',
    value: function changeState(state, detail, callback) {
      if (!this.optionMenu) {
        var optionMenu = this.element.querySelector(this.options.selectorOptionMenu);
        if (!optionMenu) {
          throw new Error('Cannot find the target menu.');
        }

        // Lazily create a component instance for menu
        this.optionMenu = FloatingMenu.create(optionMenu, {
          refNode: this.element,
          classShown: this.options.classMenuShown,
          classRefShown: this.options.classShown,
          offset: this.options.objMenuOffset
        });
        this.children.push(this.optionMenu);
      }
      if (this.optionMenu.element.classList.contains(this.options.classMenuFlip)) {
        this.optionMenu.options.offset = this.options.objMenuOffsetFlip;
      }

      // Delegates the action of changing state to the menu.
      // (And thus the before/after shown/hidden events are fired from the menu)
      this.optionMenu.changeState(state, Object.assign(detail, { delegatorNode: this.element }), callback);
    }

    /**
     * Handles click on document.
     * @param {Event} event The triggering event.
     * @private
     */

  }, {
    key: '_handleDocumentClick',
    value: function _handleDocumentClick(event) {
      var element = this.element;
      var isOfSelf = element.contains(event.target);
      var shouldBeOpen = isOfSelf && !element.classList.contains(this.options.classShown);
      var state = shouldBeOpen ? 'shown' : 'hidden';

      if (isOfSelf) {
        if (element.tagName === 'A') {
          event.preventDefault();
        }
        event.delegateTarget = element; // eslint-disable-line no-param-reassign
      }

      this.changeState(state, getLaunchingDetails(event));
    }

    /**
     * Handles key press on document.
     * @param {Event} event The triggering event.
     * @private
     */

  }, {
    key: '_handleKeyPress',
    value: function _handleKeyPress(event) {
      var key = event.which;
      if (key === 13) {
        var element = this.element;
        var isOfSelf = element.contains(event.target);
        var shouldBeOpen = isOfSelf && !element.classList.contains(this.options.classShown);
        var state = shouldBeOpen ? 'shown' : 'hidden';

        if (isOfSelf) {
          if (element.tagName === 'A') {
            event.preventDefault();
          }
          event.delegateTarget = element; // eslint-disable-line no-param-reassign
        }

        this.changeState(state, getLaunchingDetails(event));
      }
    }
  }, {
    key: 'release',
    value: function release() {
      if (this.hDocumentClick) {
        this.hDocumentClick = this.hDocumentClick.release();
      }
      if (this.hDocumentKeyPress) {
        this.hDocumentKeyPress = this.hDocumentKeyPress.release();
      }
      _get$1(OverflowMenu.prototype.__proto__ || Object.getPrototypeOf(OverflowMenu.prototype), 'release', this).call(this);
    }
  }]);

  return OverflowMenu;
}(mixin(createComponent, initComponentBySearch, exports$1));

OverflowMenu.components = new WeakMap();
OverflowMenu.options = {
  selectorInit: '[data-overflow-menu]',
  selectorOptionMenu: '.bx--overflow-menu-options',
  classShown: 'bx--overflow-menu--open',
  classMenuShown: 'bx--overflow-menu-options--open',
  classMenuFlip: 'bx--overflow-menu--flip',
  objMenuOffset: { top: 3, left: 61 },
  objMenuOffsetFlip: { top: 3, left: -61 }
};

var _createClass$12 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$6(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$13(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$12(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$12(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var initComponentByLauncher = function (ToMix) {
  /**
   * Mix-in class to instantiate components events on launcher button.
   * @class InitComponentByLauncher
   */
  var InitComponentByLauncher = function (_ToMix) {
    _inherits$12(InitComponentByLauncher, _ToMix);

    function InitComponentByLauncher() {
      _classCallCheck$13(this, InitComponentByLauncher);

      return _possibleConstructorReturn$12(this, (InitComponentByLauncher.__proto__ || Object.getPrototypeOf(InitComponentByLauncher)).apply(this, arguments));
    }

    _createClass$12(InitComponentByLauncher, null, [{
      key: 'init',

      /**
       * Instantiates this component in the given element.
       * If the given element indicates that it's an component of this class, instantiates it.
       * Otherwise, instantiates this component by clicking on launcher buttons
       * (buttons with attribute that `options.attribInitTarget` points to) of this component in the given node.
       * @param {Node} target The DOM node to instantiate this component in. Should be a document or an element.
       * @param {Object} [options] The component options.
       * @param {string} [options.selectorInit] The CSS selector to find this component.
       * @param {string} [options.attribInitTarget] The attribute name in the launcher buttons to find target component.
       * @returns {Handle} The handle to remove the event listener to handle clicking.
       */
      value: function init() {
        var _this2 = this;

        var target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        var effectiveOptions = Object.assign(Object.create(this.options), options);
        if (target.nodeType !== Node.ELEMENT_NODE && target.nodeType !== Node.DOCUMENT_NODE) {
          throw new Error('DOM document or DOM element should be given to search for and initialize this widget.');
        }
        if (target.nodeType === Node.ELEMENT_NODE && target.matches(effectiveOptions.selectorInit)) {
          this.create(target, options);
        } else {
          var handles = effectiveOptions.initEventNames.map(function (name) {
            return on(target, name, function (event) {
              var launcher = eventMatches(event, '[' + effectiveOptions.attribInitTarget + ']');

              if (launcher) {
                event.delegateTarget = launcher; // eslint-disable-line no-param-reassign
                var elements = [].concat(_toConsumableArray$6(launcher.ownerDocument.querySelectorAll(launcher.getAttribute(effectiveOptions.attribInitTarget))));
                if (elements.length > 1) {
                  throw new Error('Target widget must be unique.');
                }

                if (elements.length === 1) {
                  if (launcher.tagName === 'A') {
                    event.preventDefault();
                  }

                  var component = _this2.create(elements[0], options);
                  if (typeof component.createdByLauncher === 'function') {
                    component.createdByLauncher(event);
                  }
                }
              }
            });
          });
          return {
            release: function release() {
              for (var handle = handles.pop(); handle; handle = handles.pop()) {
                handle.release();
              }
            }
          };
        }
        return '';
      }
    }]);

    return InitComponentByLauncher;
  }(ToMix);

  return InitComponentByLauncher;
};

var _createClass$11 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$3 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck$12(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$11(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$11(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Modal = function (_mixin) {
  _inherits$11(Modal, _mixin);

  /**
   * Modal dialog.
   * @extends CreateComponent
   * @extends InitComponentByLauncher
   * @extends EventedShowHideState
   * @param {HTMLElement} element The element working as a modal dialog.
   * @param {Object} [options] The component options.
   * @param {string} [options.classVisible] The CSS class for the visible state.
   * @param {string} [options.eventBeforeShown]
   *   The name of the custom event fired before this modal is shown.
   *   Cancellation of this event stops showing the modal.
   * @param {string} [options.eventAfterShown]
   *   The name of the custom event telling that modal is sure shown
   *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
   * @param {string} [options.eventBeforeHidden]
   *   The name of the custom event fired before this modal is hidden.
   *   Cancellation of this event stops hiding the modal.
   * @param {string} [options.eventAfterHidden]
   *   The name of the custom event telling that modal is sure hidden
   *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
   */
  function Modal(element, options) {
    _classCallCheck$12(this, Modal);

    var _this = _possibleConstructorReturn$11(this, (Modal.__proto__ || Object.getPrototypeOf(Modal)).call(this, element, options));

    _this._hookCloseActions();
    return _this;
  }

  /**
   * A method that runs when `.init()` is called from `initComponentByLauncher`.
   * @param {Event} evt The event fired on the launcher button.
   */


  _createClass$11(Modal, [{
    key: 'createdByLauncher',
    value: function createdByLauncher(evt) {
      this.show(evt);
    }

    /**
     * Determines whether or not to emit events and callback function when `.changeState()` is called from `eventedState`.
     * @param {string} state The new state.
     * @returns {boolean} `true` if the given `state` is different from current state.
     */

  }, {
    key: 'shouldStateBeChanged',
    value: function shouldStateBeChanged(state) {
      if (state === 'shown') {
        return !this.element.classList.contains(this.options.classVisible);
      }

      return this.element.classList.contains(this.options.classVisible);
    }

    /**
     * Changes the shown/hidden state.
     * @private
     * @param {string} state The new state.
     * @param {Function} callback Callback called when change in state completes.
     */

  }, {
    key: '_changeState',
    value: function _changeState(state, detail, callback) {
      var _this2 = this;

      var transitionEnd = function transitionEnd() {
        _this2.element.removeEventListener('transitionend', transitionEnd);
        if (state === 'shown' && _this2.element.offsetWidth > 0 && _this2.element.offsetHeight > 0) {
          (_this2.element.querySelector(_this2.options.selectorPrimaryFocus) || _this2.element).focus();
        }
        callback();
      };

      if (state === 'hidden') {
        this.element.classList.toggle(this.options.classVisible, false);
      } else if (state === 'shown') {
        this.element.classList.toggle(this.options.classVisible, true);
      }
      this.element.addEventListener('transitionend', transitionEnd);
    }
  }, {
    key: '_hookCloseActions',
    value: function _hookCloseActions() {
      var _this3 = this;

      this.element.addEventListener('click', function (evt) {
        var closeButton = eventMatches(evt, _this3.options.selectorModalClose);
        if (closeButton) {
          evt.delegateTarget = closeButton; // eslint-disable-line no-param-reassign
        }
        if (closeButton || evt.target === _this3.element) {
          _this3.hide(evt);
        }
      });

      if (this.keydownHandler) {
        this.element.ownerDocument.body.removeEventListener('keydown', this.keydownHandler);
        this.keydownHandler = null;
      }

      this.keydownHandler = function (evt) {
        if (evt.which === 27) {
          _this3.hide(evt);
        }
      };

      this.element.ownerDocument.body.addEventListener('keydown', this.keydownHandler);
    }
  }, {
    key: 'release',
    value: function release() {
      if (this.keydownHandler) {
        this.element.ownerDocument.body.removeEventListener('keydown', this.keydownHandler);
        this.keydownHandler = null;
      }
      _get$3(Modal.prototype.__proto__ || Object.getPrototypeOf(Modal.prototype), 'release', this).call(this);
    }

    /**
     * The map associating DOM element and modal instance.
     * @member Modal.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Modal.create .create()}, or {@linkcode Modal.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Modal.init .init()} works.
     * @member Modal.options
     * @type {Object}
     * @property {string} selectorInit The CSS class to find modal dialogs.
     * @property {string} attribInitTarget The attribute name in the launcher buttons to find target modal dialogs.
     * @property {string} [classVisible] The CSS class for the visible state.
     * @property {string} [classNoScroll] The CSS class for hiding scroll bar in body element while modal is shown.
     * @property {string} [eventBeforeShown]
     *   The name of the custom event fired before this modal is shown.
     *   Cancellation of this event stops showing the modal.
     * @property {string} [eventAfterShown]
     *   The name of the custom event telling that modal is sure shown
     *   without being canceled by the event handler named by `eventBeforeShown` option (`modal-beingshown`).
     * @property {string} [eventBeforeHidden]
     *   The name of the custom event fired before this modal is hidden.
     *   Cancellation of this event stops hiding the modal.
     * @property {string} [eventAfterHidden]
     *   The name of the custom event telling that modal is sure hidden
     *   without being canceled by the event handler named by `eventBeforeHidden` option (`modal-beinghidden`).
     */

  }]);

  return Modal;
}(mixin(createComponent, initComponentByLauncher, exports$1));

Modal.components = new WeakMap();
Modal.options = {
  selectorInit: '[data-modal]',
  selectorModalClose: '[data-modal-close]',
  selectorPrimaryFocus: '[data-modal-primary-focus]',
  classVisible: 'is-visible',
  attribInitTarget: 'data-modal-target',
  initEventNames: ['click'],
  eventBeforeShown: 'modal-beingshown',
  eventAfterShown: 'modal-shown',
  eventBeforeHidden: 'modal-beinghidden',
  eventAfterHidden: 'modal-hidden'
};

var _createClass$13 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$14(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$13(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$13(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Loading = function (_mixin) {
  _inherits$13(Loading, _mixin);

  /**
   * Spinner indicating loading state.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a spinner.
   * @param {Object} [options] The component options.
   * @param {boolean} [options.active] `true` if this spinner should roll.
   */
  function Loading(element, options) {
    _classCallCheck$14(this, Loading);

    var _this = _possibleConstructorReturn$13(this, (Loading.__proto__ || Object.getPrototypeOf(Loading)).call(this, element, options));

    _this.active = _this.options.active;

    // Initialize spinner
    _this.set(_this.active);
    return _this;
  }

  /**
   * Sets active/inactive state.
   * @param {boolean} active `true` if this spinner should roll.
   */


  _createClass$13(Loading, [{
    key: 'set',
    value: function set(active) {
      if (typeof active !== 'boolean') {
        throw new TypeError('set expects a boolean.');
      }

      this.active = active;
      this.element.classList.toggle('bx--loading--stop', !this.active);

      /**
       * If overlay is the parentNode then toggle it too.
       */
      var parentNode = this.element.parentNode;

      if (parentNode && parentNode.classList.contains('bx--loading-overlay')) {
        parentNode.classList.toggle(this.options.classLoadingOverlayStop, !this.active);
      }

      return this;
    }

    /**
     * Toggles active/inactive state.
     * @param {boolean} active `true` if this spinner should roll.
     */

  }, {
    key: 'toggle',
    value: function toggle() {
      return this.set(!this.active);
    }

    /**
     * @returns {boolean} `true` if this spinner is rolling.
     */

  }, {
    key: 'isActive',
    value: function isActive() {
      return this.active;
    }

    /**
     * Sets state to inactive and deletes the loading element.
     */

  }, {
    key: 'end',
    value: function end() {
      var _this2 = this;

      this.set(false);
      this.element.addEventListener('animationend', function (evt) {
        if (evt.animationName === 'rotate-end-p2') {
          _this2._deleteElement();
        }
      });
    }

    /**
     * Delete component from the DOM.
     */

  }, {
    key: '_deleteElement',
    value: function _deleteElement() {
      var parentNode = this.element.parentNode;

      parentNode.removeChild(this.element);

      if (parentNode.classList.contains(this.options.selectorLoadingOverlay)) {
        parentNode.remove();
      }
    }

    /**
     * The map associating DOM element and spinner instance.
     * @member Loading.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Loading.create .create()}, or {@linkcode Loading.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Loading.init .init()} works.
     * @member Loading.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find spinners.
     */

  }]);

  return Loading;
}(mixin(createComponent, initComponentBySearch));

Loading.components = new WeakMap();
Loading.options = {
  selectorInit: '[data-loading]',
  selectorLoadingOverlay: '.bx--loading-overlay',
  classLoadingOverlayStop: 'bx--loading-overlay--stop',
  active: true
};

var _createClass$14 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$4 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray$7(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$15(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$14(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$14(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Dropdown = function (_mixin) {
  _inherits$14(Dropdown, _mixin);

  /**
   * A selector with drop downs.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a selector.
   * @param {Object} [options] The component options.
   * @param {string} [options.selectorItem] The CSS selector to find clickable areas in dropdown items.
   * @param {string} [options.selectorItemSelected] The CSS selector to find the clickable area in the selected dropdown item.
   * @param {string} [options.classSelected] The CSS class for the selected dropdown item.
   * @param {string} [options.eventBeforeSelected]
   *   The name of the custom event fired before a drop down item is selected.
   *   Cancellation of this event stops selection of drop down item.
   * @param {string} [options.eventAfterSelected] The name of the custom event fired after a drop down item is selected.
   */
  function Dropdown(element, options) {
    _classCallCheck$15(this, Dropdown);

    /**
     * The handle to release click event listener on document object.
     * @member {Handle}
     */
    var _this = _possibleConstructorReturn$14(this, (Dropdown.__proto__ || Object.getPrototypeOf(Dropdown)).call(this, element, options));

    _this.hDocumentClick = on(_this.element.ownerDocument, 'click', function (event) {
      _this._toggle(event);
    });

    _this._setCloseOnBlur();

    _this.element.addEventListener('keydown', function (event) {
      _this._handleKeyDown(event);
    });
    _this.element.addEventListener('click', function (event) {
      var item = eventMatches(event, _this.options.selectorItem);
      if (item) {
        _this.select(item);
      }
    });
    return _this;
  }

  /**
   * Cleans up stuffs specific to this widget.
   */


  _createClass$14(Dropdown, [{
    key: 'release',
    value: function release() {
      if (this.hFocusIn) {
        this.hFocusIn = this.hFocusIn.release();
      }
      if (this.hDocumentClick) {
        this.hDocumentClick = this.hDocumentClick.release();
      }
      _get$4(Dropdown.prototype.__proto__ || Object.getPrototypeOf(Dropdown.prototype), 'release', this).call(this);
    }

    /**
     * Handles keydown event.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: '_handleKeyDown',
    value: function _handleKeyDown(event) {
      var isOpen = this.element.classList.contains('bx--dropdown--open');
      var direction = {
        38: this.constructor.NAVIGATE.BACKWARD,
        40: this.constructor.NAVIGATE.FORWARD
      }[event.which];
      if (isOpen && direction !== undefined) {
        this.navigate(direction);
        event.preventDefault(); // Prevents up/down keys from scrolling container
      } else {
        this._toggle(event);
      }
    }

    /**
     * Opens and closes the dropdown menu.
     * @param {Event} [event] The event triggering this method.
     */

  }, {
    key: '_toggle',
    value: function _toggle(event) {
      var _this2 = this;

      if ([13, 32, 40].indexOf(event.which) >= 0 && !event.target.matches(this.options.selectorItem) || event.which === 27 || event.type === 'click') {
        var isOpen = this.element.classList.contains('bx--dropdown--open');
        var isOfSelf = this.element.contains(event.target);
        var actions = {
          add: isOfSelf && event.which === 40 && !isOpen,
          remove: (!isOfSelf || event.which === 27) && isOpen,
          toggle: isOfSelf && event.which !== 27 && event.which !== 40
        };
        Object.keys(actions).forEach(function (action) {
          if (actions[action]) {
            _this2.element.classList[action]('bx--dropdown--open');
            _this2.element.focus();
          }
        });
      }
    }

    /**
     * @returns {Element} Currently highlighted element.
     */

  }, {
    key: 'getCurrentNavigation',
    value: function getCurrentNavigation() {
      var focused = this.element.ownerDocument.activeElement;
      return focused.matches(this.options.selectorItem) ? focused : null;
    }

    /**
     * Moves up/down the focus.
     * @param {number} direction The direction of navigating.
     */

  }, {
    key: 'navigate',
    value: function navigate(direction) {
      var items = [].concat(_toConsumableArray$7(this.element.querySelectorAll(this.options.selectorItem)));
      var start = this.getCurrentNavigation() || this.element.querySelector(this.options.selectorItemSelected);
      var getNextItem = function getNextItem(old) {
        var handleUnderflow = function handleUnderflow(i, l) {
          return i + (i >= 0 ? 0 : l);
        };
        var handleOverflow = function handleOverflow(i, l) {
          return i - (i < l ? 0 : l);
        };
        // `items.indexOf(old)` may be -1 (Scenario of no previous focus)
        var index = Math.max(items.indexOf(old) + direction, -1);
        return items[handleUnderflow(handleOverflow(index, items.length), items.length)];
      };
      for (var current = getNextItem(start); current && current !== start; current = getNextItem(current)) {
        if (!current.matches(this.options.selectorItemSelected)) {
          current.focus();
          break;
        }
      }
    }

    /**
     * Handles clicking on the dropdown options, doing the following:
     * * Change Dropdown text to selected option.
     * * Remove selected option from options when selected.
     * * Emit custom events.
     * @param {HTMLElement} itemToSelect The element to be activated.
     */

  }, {
    key: 'select',
    value: function select(itemToSelect) {
      var _this3 = this;

      var eventStart = new CustomEvent(this.options.eventBeforeSelected, {
        bubbles: true,
        cancelable: true,
        detail: { item: itemToSelect }
      });

      if (this.element.dispatchEvent(eventStart)) {
        if (this.element.dataset.dropdownType !== 'navigation') {
          var text = this.element.querySelector(this.options.selectorText);
          if (text) {
            text.innerHTML = itemToSelect.innerHTML;
          }
          itemToSelect.classList.add(this.options.classSelected);
        }
        this.element.dataset.value = itemToSelect.parentElement.dataset.value;

        [].concat(_toConsumableArray$7(this.element.querySelectorAll(this.options.selectorItemSelected))).forEach(function (item) {
          if (itemToSelect !== item) {
            item.classList.remove(_this3.options.classSelected);
          }
        });

        this.element.dispatchEvent(new CustomEvent(this.options.eventAfterSelected, {
          bubbles: true,
          cancelable: true,
          detail: { item: itemToSelect }
        }));
      }
    }

    /**
     * Sets an event handler to document for "close on blur" behavior.
     */

  }, {
    key: '_setCloseOnBlur',
    value: function _setCloseOnBlur() {
      var _this4 = this;

      var hasFocusin = 'onfocusin' in window;
      var focusinEventName = hasFocusin ? 'focusin' : 'focus';
      this.hFocusIn = on(this.element.ownerDocument, focusinEventName, function (event) {
        if (!_this4.element.contains(event.target)) {
          _this4.element.classList.remove('bx--dropdown--open');
        }
      }, !hasFocusin);
    }

    /**
     * The map associating DOM element and selector instance.
     * @member Dropdown.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Dropdown.create .create()}, or {@linkcode Dropdown.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Dropdown.init .init()} works.
     * @member Dropdown.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find selectors.
     * @property {string} [selectorText] The CSS selector to find the element showing the selected item.
     * @property {string} [selectorItem] The CSS selector to find clickable areas in dropdown items.
     * @property {string} [selectorItemSelected] The CSS selector to find the clickable area in the selected dropdown item.
     * @property {string} [classSelected] The CSS class for the selected dropdown item.
     * @property {string} [eventBeforeSelected]
     *   The name of the custom event fired before a drop down item is selected.
     *   Cancellation of this event stops selection of drop down item.
     * @property {string} [eventAfterSelected] The name of the custom event fired after a drop down item is selected.
     */


    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member Dropdown.NAVIGATE
     * @type {Object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  return Dropdown;
}(mixin(createComponent, initComponentBySearch));

Dropdown.components = new WeakMap();
Dropdown.options = {
  selectorInit: '[data-dropdown]',
  selectorText: '.bx--dropdown-text',
  selectorItem: '.bx--dropdown-link',
  selectorItemSelected: '.bx--dropdown--selected',
  classSelected: 'bx--dropdown--selected',
  eventBeforeSelected: 'dropdown-beingselected',
  eventAfterSelected: 'dropdown-selected'
};
Dropdown.NAVIGATE = {
  BACKWARD: -1,
  FORWARD: 1
};

var _createClass$15 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$8(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$16(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$15(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$15(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Card = function (_mixin) {
  _inherits$15(Card, _mixin);

  /**
   * The container for cards.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a container.
   * @param {Object} [options] The component options.
   * @param {string} [options.selectorCard] The CSS selector to find cards.
   */
  function Card(element, options) {
    _classCallCheck$16(this, Card);

    var _this = _possibleConstructorReturn$15(this, (Card.__proto__ || Object.getPrototypeOf(Card)).call(this, element, options));

    _this.element.addEventListener('keydown', function (event) {
      _this._cardKeyPress(event);
    });
    return _this;
  }

  /**
   * Goes back/forward among cards,
   * right arrow key for going forward, left arrow key for going backward.
   * @param {Event} event The event triggering this method.
   */


  _createClass$15(Card, [{
    key: '_cardKeyPress',
    value: function _cardKeyPress(event) {
      var direction = {
        37: this.constructor.NAVIGATE.BACKWARD,
        39: this.constructor.NAVIGATE.FORWARD
      }[event.which];
      var card = eventMatches(event, this.options.selectorCard);

      if (direction && card && card === document.activeElement) {
        var cards = [].concat(_toConsumableArray$8(this.element.querySelectorAll(this.options.selectorCard)));
        var nextIndex = Math.max(cards.indexOf(card) + direction, -1 /* For `card` not found in `cards` */);
        var nextIndexLooped = nextIndex >= 0 && nextIndex < cards.length ? nextIndex : nextIndex - Math.sign(nextIndex) * cards.length;
        cards[nextIndexLooped].focus();
      }
    }

    /**
     * The map associating DOM element and card list instance.
     * @member Card.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode Card.create .create()}, or {@linkcode Card.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode Card.init .init()} works.
     * @member Card.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find card containers.
     * @property {string} [selectorCard] The CSS selector to find cards.
     */


    /**
     * Enum for navigating backward/forward.
     * @readonly
     * @member Card.NAVIGATE
     * @type {Object}
     * @property {number} BACKWARD Navigating backward.
     * @property {number} FORWARD Navigating forward.
     */

  }]);

  return Card;
}(mixin(createComponent, initComponentBySearch));

Card.components = new WeakMap();
Card.options = {
  selectorInit: '[data-card-list]',
  selectorCard: '.bx--card'
};
Card.NAVIGATE = {
  BACKWARD: -1,
  FORWARD: 1
};

var _createClass$16 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$17(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$16(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$16(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var NumberInput = function (_mixin) {
  _inherits$16(NumberInput, _mixin);

  /**
   * Number input UI.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a number input UI.
   */
  function NumberInput(element, options) {
    _classCallCheck$17(this, NumberInput);

    // Broken DOM tree is seen with up/down arrows <svg> in IE, which breaks event delegation.
    // <svg> does not have `Element.classList` in IE11
    var _this = _possibleConstructorReturn$16(this, (NumberInput.__proto__ || Object.getPrototypeOf(NumberInput)).call(this, element, options));

    _this.element.querySelector('.up-icon').addEventListener('click', function (event) {
      _this._handleClick(event);
    });
    _this.element.querySelector('.down-icon').addEventListener('click', function (event) {
      _this._handleClick(event);
    });
    return _this;
  }

  /**
   * Increase/decrease number by clicking on up/down icons.
   * @param {Event} event The event triggering this method.
   */


  _createClass$16(NumberInput, [{
    key: '_handleClick',
    value: function _handleClick(event) {
      var numberInput = this.element.querySelector('.bx--number input');
      var target = event.currentTarget.getAttribute('class').split(' ');

      if (target.indexOf('up-icon') >= 0) {
        ++numberInput.value;
      } else if (target.indexOf('down-icon') >= 0) {
        --numberInput.value;
      }

      // Programmatic change in value (including `stepUp()`/`stepDown()`) won't fire change event
      numberInput.dispatchEvent(new CustomEvent('change', {
        bubbles: true,
        cancelable: false
      }));
    }

    /**
     * The map associating DOM element and number input UI instance.
     * @member NumberInput.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode NumberInput.create .create()}, or {@linkcode NumberInput.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode NumberInput.init .init()} works.
     * @member NumberInput.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find number input UIs.
     */

  }]);

  return NumberInput;
}(mixin(createComponent, initComponentBySearch));

NumberInput.components = new WeakMap();
NumberInput.options = {
  selectorInit: '[data-numberinput]'
};

var _createClass$17 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$9(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$18(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$17(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$17(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DataTable = function (_mixin) {
  _inherits$17(DataTable, _mixin);

  /**
   * Data Table
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @extends EventedState
   * @param {HTMLElement} element The root element of tables
   * @param {Object} [options] the... options
   * @param {string} [options.selectorInit] selector initialization
   * @param {string} [options.selectorExpandCells] css selector for expand
   * @param {string} [options.expandableRow] css selector for expand
   * @param {string} [options.selectorParentRows] css selector for rows housing expansion
   * @param {string} [options.selectorTableBody] root css for table body
   * @param {string} [options.eventTrigger] selector for event bubble capture points
   * @param {string} [options.eventParentContainer] used find the bubble container
   */
  function DataTable(element, options) {
    _classCallCheck$18(this, DataTable);

    var _this = _possibleConstructorReturn$17(this, (DataTable.__proto__ || Object.getPrototypeOf(DataTable)).call(this, element, options));

    _initialiseProps.call(_this);

    _this.container = element.parentNode; // requires the immediate parent to be the container
    _this.tableBody = _this.element.querySelector(_this.options.selectorTableBody);
    _this.expandCells = [];
    _this.expandableRows = [];
    _this.parentRows = [];
    _this.overflowInitialized = false;

    _this.refreshRows();

    _this.element.addEventListener('click', function (evt) {
      var eventElement = eventMatches(evt, _this.options.eventTrigger);
      if (eventElement) {
        _this._toggleState(eventElement, evt);
      }
    });

    _this.element.addEventListener('keydown', function (evt) {
      if (evt.which === 13) {
        var eventElement = eventMatches(evt, _this.options.eventTrigger);
        if (eventElement) {
          _this._toggleState(eventElement, evt);
        }
      }
    });
    return _this;
  }

  /**
   * Toggles the given state.
   * @private
   * @param {Object} detail The detail of the event trigging this action.
   * @param {Function} callback Callback called when change in state completes.
   */


  _createClass$17(DataTable, [{
    key: '_changeState',
    value: function _changeState(detail, callback) {
      this[this.constructor.eventHandlers[detail.group]](detail);
      callback();
    }

    /**
     * Toggles the state of this component specified by `data-event` attribute of the given element.
     * @param {HTMLElement} element The element.
     * @param {Event} evt The event trigging this action.
     */


    /**
     * Zebra stripes - done in javascript to handle expandable rows
     */


    /**
     * Find all expandable rows and remove them from the DOM
     */


    /**
     * On trigger, insert the expandable row back in
     */


    /**
     * On trigger, flip the sort icon
     */


    /**
     * On trigger, check all checkboxes
     */


    /**
     * On fire, create the parent child rows + striping
     */

  }]);

  return DataTable;
}(mixin(createComponent, initComponentBySearch, eventedState));

DataTable.components = new WeakMap();
DataTable.eventHandlers = {
  expand: '_toggleRowExpand',
  sort: '_toggleSort',
  'select-all': '_toggleSelectAll'
};
DataTable.options = {
  selectorInit: '[data-responsive-table]',
  selectorExpandCells: '.bx--table-expand',
  selectorExpandableRows: '.bx--expandable-row',
  selectorParentRows: '.bx--parent-row',
  selectorTableBody: '.bx--table-body',
  selectorCheckbox: '.bx--checkbox',
  classParentRowEven: 'bx--parent-row--even',
  classExpandableRow: 'bx--expandable-row',
  classExpandableRowEven: 'bx--expandable-row--even',
  classExpandableRowHidden: 'bx--expandable-row--hidden',
  classTableSortAscending: 'bx--table-sort--ascending',
  eventBeforeExpand: 'responsive-table-beforetoggleexpand',
  eventAfterExpand: 'responsive-table-aftertoggleexpand',
  eventBeforeSort: 'responsive-table-beforetogglesort',
  eventAfterSort: 'responsive-table-aftertogglesort',
  eventBeforeSelectAll: 'responsive-table-beforetoggleselectall',
  eventAfterSelectAll: 'responsive-table-aftertoggleselectall',
  eventTrigger: '[data-event]',
  eventParentContainer: '[data-parent-row]'
};

var _initialiseProps = function _initialiseProps() {
  var _this2 = this;

  this._toggleState = function (element, evt) {
    var data = element.dataset;
    var label = data.label ? data.label : '';
    var previousValue = data.previousValue ? data.previousValue : '';
    var initialEvt = evt;
    _this2.changeState({
      group: data.event,
      element: element,
      label: label,
      previousValue: previousValue,
      initialEvt: initialEvt
    });
  };

  this._zebraStripe = function (parentRows) {
    parentRows.forEach(function (item, index) {
      if (index % 2 === 0) {
        item.classList.add(_this2.options.classParentRowEven);
        if (item.nextElementSibling && item.nextElementSibling.classList.contains(_this2.options.classExpandableRow)) {
          item.nextElementSibling.classList.add(_this2.options.classExpandableRowEven);
        }
      } else {
        item.classList.remove(_this2.options.classParentRowEven);
      }
    });
  };

  this._initExpandableRows = function (expandableRows) {
    expandableRows.forEach(function (item) {
      item.classList.remove(_this2.options.classExpandableRowHidden);
      _this2.tableBody.removeChild(item);
    });
  };

  this._toggleRowExpand = function (detail) {
    var element = detail.element;
    var parent = eventMatches(detail.initialEvt, _this2.options.eventParentContainer);

    var index = _this2.expandCells.indexOf(element);
    if (element.dataset.previousValue === undefined || element.dataset.previousValue === 'expanded') {
      element.dataset.previousValue = 'collapsed';
      _this2.tableBody.insertBefore(_this2.expandableRows[index], _this2.parentRows[index + 1]);
    } else {
      _this2.tableBody.removeChild(parent.nextElementSibling);
      element.dataset.previousValue = 'expanded';
    }
  };

  this._toggleSort = function (detail) {
    var element = detail.element,
        previousValue = detail.previousValue;


    if (!previousValue || previousValue === 'descending') {
      element.dataset.previousValue = 'ascending';
      element.classList.add(_this2.options.classTableSortAscending);
    } else {
      element.dataset.previousValue = 'descending';
      element.classList.remove(_this2.options.classTableSortAscending);
    }
  };

  this._toggleSelectAll = function (detail) {
    var element = detail.element,
        previousValue = detail.previousValue;

    var inputs = [].concat(_toConsumableArray$9(_this2.element.querySelectorAll(_this2.options.selectorCheckbox)));
    if (!previousValue || previousValue === 'toggled') {
      inputs.forEach(function (item) {
        item.checked = true; // eslint-disable-line no-param-reassign
      });
      element.dataset.previousValue = 'off';
    } else {
      inputs.forEach(function (item) {
        item.checked = false; // eslint-disable-line no-param-reassign
      });
      element.dataset.previousValue = 'toggled';
    }
  };

  this.refreshRows = function () {
    var newExpandCells = [].concat(_toConsumableArray$9(_this2.element.querySelectorAll(_this2.options.selectorExpandCells)));
    var newExpandableRows = [].concat(_toConsumableArray$9(_this2.element.querySelectorAll(_this2.options.selectorExpandableRows)));
    var newParentRows = [].concat(_toConsumableArray$9(_this2.element.querySelectorAll(_this2.options.selectorParentRows)));

    // check if this is a refresh or the first time
    if (_this2.parentRows.length > 0) {
      var diffParentRows = newParentRows.filter(function (newRow) {
        return !_this2.parentRows.some(function (oldRow) {
          return oldRow === newRow;
        });
      });

      // check if there are expandable rows
      if (newExpandableRows.length > 0) {
        var diffExpandableRows = diffParentRows.map(function (newRow) {
          return newRow.nextElementSibling;
        });
        var mergedExpandableRows = [].concat(_toConsumableArray$9(_this2.expandableRows), _toConsumableArray$9(diffExpandableRows));
        _this2._initExpandableRows(diffExpandableRows);
        _this2.expandableRows = mergedExpandableRows;
      }

      _this2._zebraStripe(newParentRows);
    } else {
      _this2._zebraStripe(newParentRows);

      if (newExpandableRows.length > 0) {
        _this2._initExpandableRows(newExpandableRows);
        _this2.expandableRows = newExpandableRows;
      }
    }

    _this2.expandCells = newExpandCells;
    _this2.parentRows = newParentRows;
  };
};

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;
var nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var index = debounce;

var _createClass$18 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$5 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck$19(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$18(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$18(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var DetailPageHeader = function (_mixin) {
  _inherits$18(DetailPageHeader, _mixin);

  /**
   * The Detail Page Header.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a page header.
   * @param {Object} [options] The component options.
   */
  function DetailPageHeader(element, options) {
    _classCallCheck$19(this, DetailPageHeader);

    var _this = _possibleConstructorReturn$18(this, (DetailPageHeader.__proto__ || Object.getPrototypeOf(DetailPageHeader)).call(this, element, options));

    _this.previousScrollY = 0;
    // Debounce scroll event calls to handleScroll (default: 50)
    var debouncedScroll = index(_this._handleScroll.bind(_this), 25);
    _this.hScroll = on(_this.element.ownerDocument.defaultView, 'scroll', debouncedScroll);
    return _this;
  }

  /**
   * Adds class to header based on users position on the page
   */


  _createClass$18(DetailPageHeader, [{
    key: '_handleScroll',
    value: function _handleScroll() {
      var scrollPosition = void 0;
      if (this.element.ownerDocument.defaultView.pageYOffset) {
        scrollPosition = this.element.ownerDocument.defaultView.pageYOffset;
      } else {
        scrollPosition = this.element.ownerDocument.defaultView.pageYOffset;
      }

      if (scrollPosition > 86) {
        this.element.dataset.headerActive = true;
        if (scrollPosition < this.previousScrollY) {
          this.element.classList.remove(this.options.scroll);
        } else {
          this.element.classList.add(this.options.scroll);
        }
      } else {
        this.element.classList.remove(this.options.scroll);
        this.element.dataset.headerActive = false;
      }

      this.previousScrollY = scrollPosition;
    }

    /**
     * Cleans up stuffs specific to this widget.
     */

  }, {
    key: 'release',
    value: function release() {
      this.hScroll.release();
      _get$5(DetailPageHeader.prototype.__proto__ || Object.getPrototypeOf(DetailPageHeader.prototype), 'release', this).call(this);
    }

    /**
     * The map associating DOM element and detail page header instance.
     * @member DetailPageHeader.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode DetailPageHeader.create .create()}, or {@linkcode DetailPageHeader.init .init()},
     * properties in this object are overriden for the instance being created
     * and how {@linkcode DetailPageHeader.init .init()} works.
     * @member DetailPageHeader.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find detail page headers.
     */

  }]);

  return DetailPageHeader;
}(mixin(createComponent, initComponentBySearch));

DetailPageHeader.components = new WeakMap();
DetailPageHeader.options = {
  selectorInit: '[data-detail-page-header]',
  scroll: 'bx--detail-page-header--scroll'
};

var _createClass$19 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$6 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray$10(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$20(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$19(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$19(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LeftNav = function (_mixin) {
  _inherits$19(LeftNav, _mixin);

  /**
   * Left Navigation.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a left navigation.
   * @param {Object} [options] The component options
   * @param {string} [options.selectorLeftNav] The data attribute selector for the nav element in the left nav container.
   * @param {string} [options.selectorLeftNavList] The data attribute selector for the main ul element in the left nav.
   * @param {string} [options.selectorLeftNavNestedList] The data attribute selector for the nested ul elements in the left nav.
   * @param {string} [options.selectorLeftNavToggle]
   *   The data attribute selector for the button that will show and hide the left navigation.
   * @param {string} [options.selectorLeftNavListItem] The data attribute selector for all list items in the left navigation.
   * @param {string} [options.selectorLeftNavNestedListItem]
   *   The data attribute selector for all nested list items in the left navigation.
   * @param {string} [options.selectorLeftNavArrowIcon] The data attribute selector for the arrow icons in the left nav.
   * @param {string} [options.selectorLeftNavFlyoutMenu] The data attribute selector for the flyout menus in the left nav.
   * @param {string} [options.selectorLeftNavFlyoutItem] The data attribute selector for the flyout menu items in the left nav.
   * @param {string} [options.selectorLeftNavSection]
   *   The data attribute selector for the three sections in the header of the left nav.
   * @param {string} [options.selectorLeftNavCurrentPage]
   *   The data attribute selector for the current section title in the left nav header.
   * @param {string} [options.classActiveLeftNav] The class name for when a left nav is active.
   * @param {string} [options.classActiveLeftNavListItem] The class name for when a left nav list item is active.
   * @param {string} [options.classExpandedLeftNavListItem] The class name for when a nested list is expanded.
   * @param {string} [options.classFlyoutDisplayed] The class name for when a flyout menu is displayed.
   * @param {string} [options.classActiveSection] The class name for an active section item in the left nav header.
   * @param {string} [options.classItemHasChildren] The class name for when a list item has children.
   */
  function LeftNav(element, options) {
    _classCallCheck$20(this, LeftNav);

    var _this = _possibleConstructorReturn$19(this, (LeftNav.__proto__ || Object.getPrototypeOf(LeftNav)).call(this, element, options));

    _this.leftNavSectionActive = false;
    _this.hookOpenActions();
    _this.hookListSectionEvents();
    _this.hookListItemsEvents();
    _this.hDocumentClick = on(_this.element.ownerDocument, 'click', function (evt) {
      _this.handleDocumentClick(evt);
    });
    return _this;
  }

  /**
   * Closes the menu.
   */


  _createClass$19(LeftNav, [{
    key: 'closeMenu',
    value: function closeMenu() {
      this.element.classList.remove(this.options.classActiveLeftNav);
      var toggleOpenNode = this.element.ownerDocument.querySelector(this.options.selectorLeftNavToggleOpen);
      toggleOpenNode.classList.remove(this.options.classActiveTrigger);
      this.element.querySelector(this.options.selectorLeftNav).parentNode.setAttribute('aria-expanded', 'false');
    }

    /**
     * Toggles the menu to open and close.
     */

  }, {
    key: 'toggleMenu',
    value: function toggleMenu() {
      var leftNavContainer = this.element.querySelector(this.options.selectorLeftNav).parentNode;
      this.element.classList.toggle(this.options.classActiveLeftNav);
      var toggleOpenNode = this.element.ownerDocument.querySelector(this.options.selectorLeftNavToggleOpen);
      toggleOpenNode.classList.toggle(this.options.classActiveTrigger);
      if (leftNavContainer.getAttribute('aria-expanded') === 'false') leftNavContainer.setAttribute('aria-expanded', 'true');else leftNavContainer.setAttribute('aria-expanded', 'false');
    }

    /**
     * Adds a transitional animation to the navSection
     */

  }, {
    key: 'animateNavSection',
    value: function animateNavSection(selectedNav) {
      var _this2 = this;

      var selectedNavValue = selectedNav.dataset.leftNavSection;
      var selectedNavLink = selectedNav.querySelector(this.options.selectorLeftNavSectionLink);
      var leftNav = this.element.querySelector(this.options.selectorLeftNav);
      var leftNavSections = this.element.querySelector(this.options.selectorLeftNavSections);

      selectedNav.classList.remove(this.options.classNavSection);
      selectedNav.classList.remove(this.options.classNavSection + '--' + selectedNavValue);
      selectedNav.classList.add(this.options.classNavSectionTransition);
      if (leftNavSections.children[0] === selectedNav) {
        selectedNav.classList.add(this.options.classNavSectionTransition + '--50'); // First child only move 50px
      } else {
        selectedNav.classList.add(this.options.classNavSectionTransition + '--100'); // Second move 100px
      }
      selectedNav.setAttribute('data-left-nav-section', selectedNavValue);
      /* Not sure what trick more performant*/
      setTimeout(function () {
        selectedNav.classList.add(_this2.options.classNavSectionTransition + '--0');
      }, 100); // Could probably use a promise here

      selectedNavLink.classList.remove(this.options.classNavSectionLink);
      selectedNavLink.classList.add(this.options.classNavHeaderTitle);
      selectedNavLink.setAttribute('data-left-nav-current-section-title', '');
      selectedNavLink.removeAttribute('data-left-nav-section-link');

      this.element.insertBefore(selectedNav, leftNav);
    }

    /**
     * Adds a transitional animation to the navigation items on nav section click
     */

  }, {
    key: 'animateNavList',
    value: function animateNavList(selectedNavTitle) {
      var _this3 = this;

      var currentLeftNavList = this.element.querySelector(this.options.selectorLeftNavList + ':not(.bx--left-nav__main-nav--hidden)');
      var newLeftNavList = this.element.querySelector('[data-left-nav-list=' + selectedNavTitle + ']');
      var currentLeftNavItems = [].concat(_toConsumableArray$10(currentLeftNavList.querySelectorAll(this.options.selectorLeftNavListItem))).reverse();
      var newLeftNavItems = [].concat(_toConsumableArray$10(newLeftNavList.querySelectorAll(this.options.selectorLeftNavListItem)));

      var fadeOutTime = 300;
      var counter = 0;
      var counterIteration = fadeOutTime / currentLeftNavItems.length; // Length of animation divided by number of items
      currentLeftNavItems.forEach(function (item) {
        item.setAttribute('tabIndex', '-1');
        setTimeout(function () {
          item.classList.add(_this3.options.classItemFade);
        }, counter);
        counter += counterIteration;
      });

      newLeftNavItems.forEach(function (item) {
        item.setAttribute('tabIndex', '0');
        item.classList.remove(_this3.options.classItemFade);
      });

      setTimeout(function () {
        currentLeftNavList.classList.add(_this3.options.classListHidden);
        currentLeftNavList.classList.add(_this3.options.classListTop);
        currentLeftNavList.setAttribute('aria-hidden', 'true');
        newLeftNavList.classList.remove(_this3.options.classListHidden);
        setTimeout(function () {
          newLeftNavList.classList.remove(_this3.options.classListTop);
        }, 100);
        newLeftNavList.setAttribute('aria-hidden', 'false');
      }, fadeOutTime + 100); // Wait for items to fade out.
    }
  }, {
    key: 'hookOpenActions',
    value: function hookOpenActions() {
      var _this4 = this;

      var openBtn = this.element.ownerDocument.querySelector(this.options.selectorLeftNavToggleOpen);
      var closeBtn = this.element.ownerDocument.querySelector(this.options.selectorLeftNavToggleClose);

      openBtn.addEventListener('click', function () {
        _this4.element.tabIndex = '0';
        _this4.toggleMenu();
      });

      openBtn.addEventListener('keydown', function (evt) {
        if (evt.which === 13) {
          _this4.element.tabIndex = '0';
          _this4.toggleMenu();
        }
      });

      if (closeBtn) {
        closeBtn.addEventListener('click', function () {
          _this4.element.tabIndex = '-1';
          _this4.closeMenu();
        });

        closeBtn.addEventListener('keydown', function (evt) {
          if (evt.which === 13) {
            _this4.element.tabIndex = '-1';
            _this4.closeMenu();
          }
        });
      }

      this.element.ownerDocument.addEventListener('keydown', function (evt) {
        if (evt.which === 27 && _this4.element.classList.contains(_this4.options.classActiveLeftNav)) {
          _this4.closeMenu();
        }
      });
    }

    /**
     * Addes Event listeners to list sections
     */

  }, {
    key: 'hookListSectionEvents',
    value: function hookListSectionEvents() {
      var _this5 = this;

      var leftNavSections = this.element.querySelector(this.options.selectorLeftNavSections);
      leftNavSections.addEventListener('click', function (evt) {
        _this5.handleSectionItemClick(evt, leftNavSections);
      });

      leftNavSections.addEventListener('keydown', function (evt) {
        if (evt.which === 13) {
          _this5.handleSectionItemClick(evt, leftNavSections);
          _this5.element.querySelector(_this5.options.selectorLeftNavCurrentSectionTitle).focus();
        }
      });
    }

    /**
     * Adds event listeners to list items
     */

  }, {
    key: 'hookListItemsEvents',
    value: function hookListItemsEvents() {
      var _this6 = this;

      var leftNavList = [].concat(_toConsumableArray$10(this.element.querySelectorAll(this.options.selectorLeftNavList)));
      leftNavList.forEach(function (list) {
        list.addEventListener('click', function (evt) {
          var leftNavItem = eventMatches(evt, _this6.options.selectorLeftNavListItem);
          if (leftNavItem) {
            var childItem = eventMatches(evt, _this6.options.selectorLeftNavNestedListItem);
            var hasChildren = eventMatches(evt, _this6.options.selectorLeftNavListItemHasChildren);
            var flyoutItem = eventMatches(evt, _this6.options.selectorLeftNavFlyoutItem);
            if (flyoutItem) {
              _this6.addActiveListItem(flyoutItem);
            } else if (childItem) {
              if (childItem.querySelector(_this6.options.selectorLeftNavFlyoutMenu)) {
                var flyoutMenu = childItem.querySelector(_this6.options.selectorLeftNavFlyoutMenu);
                flyoutMenu.classList.toggle(_this6.options.classFlyoutDisplayed);
              } else {
                _this6.addActiveListItem(childItem);
              }
            } else if (hasChildren) {
              _this6.handleNestedListClick(leftNavItem);
            } else {
              _this6.addActiveListItem(leftNavItem);
            }
          }
        });
        list.addEventListener('keydown', function (evt) {
          if (evt.which === 13) {
            var leftNavItem = eventMatches(evt, _this6.options.selectorLeftNavListItem);
            if (leftNavItem) {
              var childItem = eventMatches(evt, _this6.options.selectorLeftNavNestedListItem);
              var hasChildren = eventMatches(evt, _this6.options.selectorLeftNavListItemHasChildren);
              var flyoutItem = eventMatches(evt, _this6.options.selectorLeftNavFlyoutItem);
              if (flyoutItem) {
                _this6.addActiveListItem(flyoutItem);
              } else if (childItem) {
                if (!childItem.querySelector(_this6.options.selectorLeftNavFlyoutMenu)) {
                  _this6.addActiveListItem(childItem);
                } else {
                  childItem.querySelector(_this6.options.selectorLeftNavFlyoutMenu).setAttribute('aria-hidden', 'false');
                  childItem.querySelector(_this6.options.selectorLeftNavFlyoutMenu).style.top = childItem.offsetTop - _this6.element.querySelector(_this6.options.selectorLeftNav).scrollTop + 'px';
                  childItem.querySelector(_this6.options.selectorLeftNavFlyoutMenu).style.left = childItem.offsetLeft + Math.round(childItem.offsetWidth) + 'px';
                }
              } else if (hasChildren) {
                _this6.handleNestedListClick(leftNavItem);
              } else {
                _this6.addActiveListItem(leftNavItem);
              }
            }
          }
        });
      });
      var flyouts = [].concat(_toConsumableArray$10(this.element.ownerDocument.querySelectorAll(this.options.selectorLeftNavListItemHasFlyout)));
      flyouts.forEach(function (flyout) {
        flyout.addEventListener('mouseenter', function () {
          flyout.querySelector(_this6.options.selectorLeftNavFlyoutMenu).setAttribute('aria-hidden', 'false');
          // eslint-disable-next-line no-param-reassign
          flyout.querySelector(_this6.options.selectorLeftNavFlyoutMenu).style.top = flyout.offsetTop - _this6.element.querySelector(_this6.options.selectorLeftNav).scrollTop + 'px';
          // eslint-disable-next-line no-param-reassign
          flyout.querySelector(_this6.options.selectorLeftNavFlyoutMenu).style.left = flyout.offsetLeft + Math.round(flyout.offsetWidth) + 'px';
          flyout.querySelector(_this6.options.selectorLeftNavFlyoutMenu).classList.toggle(_this6.options.classFlyoutDisplayed);
        });
        flyout.addEventListener('mouseleave', function () {
          flyout.querySelector(_this6.options.selectorLeftNavFlyoutMenu).setAttribute('aria-hidden', 'true');
          flyout.querySelector(_this6.options.selectorLeftNavFlyoutMenu).classList.remove(_this6.options.classFlyoutDisplayed);
        });
      });
    }

    /**
     * Hides all flyout menus.
     */

  }, {
    key: 'hideAllFlyoutMenus',
    value: function hideAllFlyoutMenus() {
      var _this7 = this;

      var flyoutMenus = [].concat(_toConsumableArray$10(this.element.querySelectorAll(this.options.selectorLeftNavFlyoutMenu)));
      flyoutMenus.forEach(function (menu) {
        menu.setAttribute('aria-hidden', 'true');
        menu.classList.remove(_this7.options.classFlyoutDisplayed);
      });
    }

    /**
     * Sets a list item as active.
     * @param {Object} item The active list item.
     */

  }, {
    key: 'addActiveListItem',
    value: function addActiveListItem(item) {
      var _this8 = this;

      [].concat(_toConsumableArray$10(this.element.querySelectorAll(this.options.selectorLeftNavAllListItems))).forEach(function (currentItem) {
        if (!(item === currentItem)) {
          if (!currentItem.contains(item)) {
            currentItem.classList.remove(_this8.options.classActiveLeftNavListItem);
          } else {
            currentItem.classList.add(_this8.options.classActiveLeftNavListItem);
          }
        }
      });
      [].concat(_toConsumableArray$10(this.element.querySelectorAll(this.options.selectorLeftNavNestedListItem))).forEach(function (currentItem) {
        if (!(item === currentItem)) {
          currentItem.classList.remove(_this8.options.classActiveLeftNavListItem);
        }
      });
      item.classList.add(this.options.classActiveLeftNavListItem);
      this.closeMenu();
      this.hideAllFlyoutMenus();
      this.closeMenu();
    }

    /**
     * Handles click on the document.
     * Closes the left navigation when document is clicked outside the left navigation.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: 'handleDocumentClick',
    value: function handleDocumentClick(evt) {
      var clickTarget = evt.target;
      var isOfSelf = this.element.contains(clickTarget);
      var isToggleBtn = this.element.ownerDocument.querySelector(this.options.selectorLeftNavToggleOpen).contains(clickTarget);
      var isOpen = this.element.classList.contains(this.options.classActiveLeftNav);
      var isUnifiedHeader = this.element.ownerDocument.querySelector('[data-unified-header]').contains(clickTarget);
      var shouldClose = !isOfSelf && isOpen && !isToggleBtn && !isUnifiedHeader;
      var flyoutOpen = void 0;
      if (this.element.querySelector(this.options.selectorLeftNavFlyoutMenu)) {
        var leftnavFlyoutMenu = this.element.querySelector(this.options.selectorLeftNavFlyoutMenu);
        flyoutOpen = leftnavFlyoutMenu.classList.contains(this.options.classFlyoutDisplayed);
      }
      if (isOfSelf && this.element.tagName === 'A') {
        evt.preventDefault();
      }
      if (shouldClose) {
        this.closeMenu();
      }
      if (this.element.querySelector(this.options.selectorLeftNavFlyoutMenu)) {
        if (flyoutOpen && !isOfSelf && isOpen) {
          this.element.querySelector(this.options.selectorLeftNavFlyoutMenu).classList.remove(this.options.classFlyoutDisplayed);
        }
      }
    }

    /**
     * Handles click on a list item that contains a nested list in the left navigation.
     * It hides all flyout menus and switches the tab-index on the list items based on whether or not the list is expanded.
     * @param {HTMLElement} listItem The list item that was clicked.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: 'handleNestedListClick',
    value: function handleNestedListClick(listItem) {
      var _this9 = this;

      var isOpen = listItem.classList.contains(this.options.classExpandedLeftNavListItem);
      this.hideAllFlyoutMenus();
      listItem.classList.toggle(this.options.classExpandedLeftNavListItem, !isOpen);
      var listItems = [].concat(_toConsumableArray$10(listItem.querySelectorAll(this.options.selectorLeftNavNestedListItem)));
      listItems.forEach(function (item) {
        if (isOpen) {
          listItem.querySelector(_this9.options.selectorLeftNavNestedList).setAttribute('aria-hidden', 'true');
          // eslint-disable-next-line no-param-reassign
          item.querySelector(_this9.options.selectorLeftNavListItemLink).tabIndex = -1;
        } else {
          listItem.querySelector(_this9.options.selectorLeftNavNestedList).setAttribute('aria-hidden', 'false');
          // eslint-disable-next-line no-param-reassign
          item.querySelector(_this9.options.selectorLeftNavListItemLink).tabIndex = 0;
        }
      });
    }
  }, {
    key: 'handleSectionItemClick',
    value: function handleSectionItemClick(evt, leftNavSections) {
      var _this10 = this;

      // Sorry
      var leftNavSectionItem = eventMatches(evt, this.options.selectorLeftNavSection);
      if (leftNavSectionItem) {
        // currently selected
        var selectedLeftNavSectionItem = this.element.querySelector(this.options.selectorLeftNavCurrentSection);
        var selectedLeftNavSectionItemTitle = selectedLeftNavSectionItem.querySelector(this.options.selectorLeftNavCurrentSectionTitle);
        var selectedLeftNavSectionItemIcon = this.element.querySelector(this.options.selectorLeftNavCurrentSectionIcon);
        var selectedLeftNavSectionItemUse = selectedLeftNavSectionItemIcon.querySelector('use');
        var selectedLeftNavSectionValue = selectedLeftNavSectionItem.dataset.leftNavCurrentSection;

        // clicked on item
        var leftNavSectionItemLink = leftNavSectionItem.querySelector(this.options.selectorLeftNavSectionLink);
        var leftNavSectionItemIcon = leftNavSectionItem.querySelector(this.options.selectorLeftNavSectionIcon);
        var leftNavSectionItemIconUse = leftNavSectionItemIcon.querySelector('use');
        var leftNavSectionValue = leftNavSectionItem.dataset.leftNavSection;

        if (this.leftNavSectionActive) {
          return;
        }
        this.leftNavSectionActive = true;

        var newLeftNavSectionItem = document.createElement('li');
        newLeftNavSectionItem.setAttribute('data-left-nav-section', selectedLeftNavSectionValue);
        newLeftNavSectionItem.classList.add(this.options.classNavSection);
        newLeftNavSectionItem.classList.add(this.options.classNavSection + '--' + selectedLeftNavSectionValue);

        var newLeftNavSectionItemAnchor = document.createElement('a');
        newLeftNavSectionItemAnchor.setAttribute('href', 'javascript:void(0)'); // eslint-disable-line no-script-url
        newLeftNavSectionItemAnchor.setAttribute('tabindex', 0);
        newLeftNavSectionItemAnchor.classList.add(this.options.classNavSectionAnchor);

        var newLeftNavSectionItemIcon = selectedLeftNavSectionItemIcon.cloneNode(true);
        // IE11 doesn't support classList on SVG, must revert to className
        newLeftNavSectionItemIcon.setAttribute('class', 'bx--left-nav__section--taxonomy-icon');
        newLeftNavSectionItemIcon.removeAttribute('data-left-nav-current-section-icon');
        newLeftNavSectionItemIcon.setAttribute('data-left-nav-section-icon', selectedLeftNavSectionValue);

        var newLeftNavSectionItemLink = document.createElement('span');
        newLeftNavSectionItemLink.setAttribute('data-left-nav-section-link', '');
        newLeftNavSectionItemLink.classList.add(this.options.classNavSectionLink);
        newLeftNavSectionItemLink.textContent = selectedLeftNavSectionItemTitle.textContent;

        this.animateNavSection(leftNavSectionItem);
        this.animateNavList(leftNavSectionValue);

        newLeftNavSectionItemAnchor.appendChild(newLeftNavSectionItemIcon);
        newLeftNavSectionItemAnchor.appendChild(newLeftNavSectionItemLink);
        newLeftNavSectionItem.appendChild(newLeftNavSectionItemAnchor);
        leftNavSections.insertBefore(newLeftNavSectionItem, leftNavSections.firstChild);

        setTimeout(function () {
          selectedLeftNavSectionItemTitle.textContent = leftNavSectionItemLink.textContent;
          selectedLeftNavSectionItem.setAttribute('data-left-nav-current-section', leftNavSectionValue);
          selectedLeftNavSectionItemIcon.setAttribute('data-left-nav-current-section-icon', leftNavSectionValue);
          selectedLeftNavSectionItemUse.setAttribute('xlink:href', leftNavSectionItemIconUse.getAttribute('xlink:href'));

          leftNavSectionItem.parentNode.removeChild(leftNavSectionItem); // Cant use .remove() because of IE11
          _this10.leftNavSectionActive = false;
        }, 450); // Wait for nav items to animate
      }
    }
  }, {
    key: 'release',
    value: function release() {
      if (this.hDocumentClick) {
        this.hDocumentClick = this.hDocumentClick.release();
      }
      _get$6(LeftNav.prototype.__proto__ || Object.getPrototypeOf(LeftNav.prototype), 'release', this).call(this);
    }

    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode LeftNav.create .create()}, or {@linkcode LeftNav.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode LeftNav.init .init()} works.
     * @member LeftNav.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find left nav containers.
     * @property {string} [selectorLeftNav] The data attribute selector for the nav element in the left nav container.
     * @property {string} [selectorLeftNavList] The data attribute selector for the main ul element in the left nav.
     * @property {string} [selectorLeftNavNestedList] The data attribute selector for the nested ul elements in the left nav.
     * @property {string} [selectorLeftNavToggle]
     *   The data attribute selector for the button that will show and hide the left navigation.
     * @property {string} [selectorLeftNavListItem] The data attribute selector for all list items in the left navigation.
     * @property {string} [selectorLeftNavNestedListItem]
     *   The data attribute selector for all nested list items in the left navigation.
     * @property {string} [selectorLeftNavArrowIcon] The data attribute selector for the arrow icons in the left nav.
     * @property {string} [selectorLeftNavFlyoutMenu] The data attribute selector for the flyout menus in the left nav.
     * @property {string} [selectorLeftNavFlyoutItem] The data attribute selector for the flyout menu items in the left nav.
     * @property {string} [selectorLeftNavSection] The data attribute selector for the three sections in the header of the left nav.
     * @property {string} [selectorLeftNavCurrentPage]
     *   The data attribute selector for the current section title in the left nav header.
     * @property {string} [classActiveLeftNav] The class name for when a left nav is active.
     * @property {string} [classActiveLeftNavListItem] The class name for when a left nav list item is active.
     * @property {string} [classExpandedLeftNavListItem] The class name for when a nested list is expanded.
     * @property {string} [classFlyoutDisplayed] The class name for when a flyout menu is displayed.
     * @property {string} [classActiveSection] The class name for an active section item in the left nav header.
     * @property {string} [classItemHasChildren] The class name for when a list item has children.
     */


    /**
     * The map associating DOM element and left navigation instance.
     * @member LeftNav.components
     * @type {WeakMap}
     */

  }]);

  return LeftNav;
}(mixin(createComponent, initComponentBySearch));

LeftNav.options = {
  selectorInit: '[data-left-nav-container]',
  // Data Attribute selectors
  selectorLeftNav: '[data-left-nav]',
  selectorLeftNavList: '[data-left-nav-list]',
  selectorLeftNavNestedList: '[data-left-nav-nested-list]',
  selectorLeftNavToggleOpen: '[data-left-nav-toggle="open"]',
  selectorLeftNavToggleClose: '[data-left-nav-toggle="close"]',
  selectorLeftNavListItem: '[data-left-nav-item]',
  selectorLeftNavListItemLink: '[data-left-nav-item-link]',
  selectorLeftNavNestedListItem: '[data-left-nav-nested-item]',
  selectorLeftNavArrowIcon: '[data-left-nav-icon]',
  selectorLeftNavFlyoutMenu: '[data-left-nav-flyout]',
  selectorLeftNavFlyoutItem: '[data-left-nav-flyout-item]',
  selectorLeftNavSections: '[data-left-nav-sections]',
  selectorLeftNavSection: '[data-left-nav-section]',
  selectorLeftNavSectionLink: '[data-left-nav-section-link]',
  selectorLeftNavSectionIcon: '[data-left-nav-section-icon]',
  selectorLeftNavCurrentSection: '[data-left-nav-current-section]',
  selectorLeftNavCurrentSectionTitle: '[data-left-nav-current-section-title]',
  selectorLeftNavCurrentSectionIcon: '[data-left-nav-current-section-icon]',
  selectorLeftNavListItemHasChildren: '[data-left-nav-item-with-children]',
  selectorLeftNavListItemHasFlyout: '[data-left-nav-has-flyout]',
  selectorLeftNavAllListItems: '[data-left-nav-item], [data-left-nav-nested-item], [data-left-nav-flyout-item]',
  // CSS Class Selectors
  classActiveTrigger: 'bx--left-nav__trigger--active',
  classActiveLeftNav: 'bx--left-nav--active',
  classActiveLeftNavListItem: 'bx--active-list-item',
  classExpandedLeftNavListItem: 'bx--main-nav__parent-item--expanded',
  classFlyoutDisplayed: 'bx--nested-list__flyout-menu--displayed',
  classItemHasChildren: 'bx--main-nav__parent-item--has-children',
  classNavSection: 'bx--left-nav__section',
  classNavSectionTransition: 'bx--left-nav__section--transition',
  classNavSectionAnchor: 'bx--left-nav__section--anchor',
  classNavSectionLink: 'bx--left-nav__section--link',
  classNavHeaderTitle: 'bx--left-nav__header--title',
  classItemFade: 'bx--main-nav__parent-item--fade',
  classItemHidden: 'bx--main-nav__parent-item--hidden',
  classListHidden: 'bx--left-nav__main-nav--hidden',
  classListTop: 'bx--left-nav__main-nav--top'
};
LeftNav.components = new WeakMap();

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function svgToggleClass(svg, name, forceAdd) {
  var list = svg.getAttribute('class').trim().split(/\s+/);
  var uniqueList = Object.keys(list.reduce(function (o, item) {
    return Object.assign(o, _defineProperty({}, item, 1));
  }, {}));
  var index = uniqueList.indexOf(name);
  var found = index >= 0;
  var add = forceAdd === undefined ? !found : forceAdd;

  if (found === !add) {
    if (add) {
      uniqueList.push(name);
    } else {
      uniqueList.splice(index, 1);
    }
    svg.setAttribute('class', uniqueList.join(' '));
  }
}

var _createClass$20 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$11(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$21(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$20(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$20(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var InteriorLeftNav = function (_mixin) {
  _inherits$20(InteriorLeftNav, _mixin);

  /**
   * Interior left nav.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as an interior left nav.
   * @param {Object} options The component options.
   */
  function InteriorLeftNav(element, options) {
    _classCallCheck$21(this, InteriorLeftNav);

    var _this = _possibleConstructorReturn$20(this, (InteriorLeftNav.__proto__ || Object.getPrototypeOf(InteriorLeftNav)).call(this, element, options));

    _this.hookListItemsEvents = function () {
      _this.element.addEventListener('click', function (evt) {
        var leftNavItem = eventMatches(evt, _this.options.selectorLeftNavListItem);
        var collapseEl = eventMatches(evt, _this.options.selectorLeftNavCollapse);
        var collapsedBar = eventMatches(evt, '.' + _this.options.classLeftNavCollapsed);

        if (leftNavItem) {
          var childItem = eventMatches(evt, _this.options.selectorLeftNavNestedListItem);
          var hasChildren = leftNavItem.classList.contains('left-nav-list__item--has-children');
          if (childItem) {
            _this.addActiveListItem(childItem);
          } else if (hasChildren) {
            _this.handleNestedListClick(leftNavItem, evt);
          } else {
            _this.addActiveListItem(leftNavItem);
          }
        }

        if (collapseEl || collapsedBar) {
          evt.preventDefault();
          _this.toggleLeftNav();
        }
      });

      _this.element.addEventListener('keydown', function (evt) {
        var leftNavItemWithChildren = eventMatches(evt, _this.options.selectorLeftNavListItemHasChildren);
        var leftNavItem = eventMatches(evt, _this.options.selectorLeftNavListItem);

        if (leftNavItemWithChildren && evt.which === 13) {
          _this.handleNestedListClick(leftNavItemWithChildren, evt);
        } else if (leftNavItem && evt.which === 13) {
          _this.addActiveListItem(leftNavItem);
        }
      });
    };

    _this.toggleLeftNav = function () {
      var collapsed = _this.element.dataset.collapsed === 'true';
      var eventStart = new CustomEvent(_this.options.eventBeforeLeftNavToggled, {
        bubbles: true,
        cancelable: true,
        detail: { collapsed: !collapsed } });

      if (_this.element.dispatchEvent(eventStart)) {
        if (!collapsed) {
          _this.element.dataset.collapsed = true;
          _this.element.classList.add(_this.options.classLeftNavCollapsing);

          window.setTimeout(function () {
            _this.element.classList.remove(_this.options.classLeftNavCollapsing);
            _this.element.classList.add(_this.options.classLeftNavCollapsed);
            _this.element.dispatchEvent(new CustomEvent(_this.options.eventAfterLeftNavToggled, {
              bubbles: true,
              cancelable: true,
              detail: { collapsed: true }
            }));
          }, 250);
        } else {
          _this.element.dataset.collapsed = false;
          _this.element.classList.remove(_this.options.classLeftNavCollapsed);
          _this.element.classList.add(_this.options.classLeftNavExpanding);

          window.setTimeout(function () {
            _this.element.classList.remove(_this.options.classLeftNavExpanding);
            _this.element.dispatchEvent(new CustomEvent(_this.options.eventAfterLeftNavToggled, {
              bubbles: true,
              cancelable: true,
              detail: { collapsed: false }
            }));
          }, 250);
        }
      }
    };

    _this.constructor.components.set(_this.element, _this);
    _this.hookListItemsEvents();
    return _this;
  }

  _createClass$20(InteriorLeftNav, [{
    key: 'addActiveListItem',
    value: function addActiveListItem(item) {
      var _this2 = this;

      [].concat(_toConsumableArray$11(this.element.querySelectorAll(this.options.selectorLeftNavListItem))).forEach(function (currentItem) {
        if (!(item === currentItem)) {
          currentItem.classList.remove(_this2.options.classActiveLeftNavListItem);
        }
      });
      [].concat(_toConsumableArray$11(this.element.querySelectorAll(this.options.selectorLeftNavNestedListItem))).forEach(function (currentItem) {
        if (!(item === currentItem)) {
          currentItem.classList.remove(_this2.options.classActiveLeftNavListItem);
        }
      });
      item.classList.add(this.options.classActiveLeftNavListItem);
    }

    /**
     * Handles click on a list item that contains a nested list in the left navigation.
     * The nested list is expanded and the icon is rotated.
     * @param {HTMLElement} listItem The list item that was clicked.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: 'handleNestedListClick',
    value: function handleNestedListClick(listItem, evt) {
      var _this3 = this;

      var allNestedItems = [].concat(_toConsumableArray$11(document.querySelectorAll(this.options.selectorLeftNavListItemHasChildren)));
      var isOpen = listItem.classList.contains(this.options.classExpandedLeftNavListItem);
      allNestedItems.forEach(function (currentItem) {
        if (currentItem !== listItem) {
          svgToggleClass(currentItem, _this3.options.classExpandedLeftNavListItem, false);
        }
      });
      if (!('InteriorLeftNavItemLink' in evt.target.dataset)) {
        svgToggleClass(listItem, this.options.classExpandedLeftNavListItem, !isOpen);
      }
      var list = listItem.querySelector(this.options.selectorLeftNavNestedList);
      var listItems = [].concat(_toConsumableArray$11(list.querySelectorAll(this.options.selectorLeftNavNestedListItem)));
      listItems.forEach(function (item) {
        if (isOpen) {
          // eslint-disable-next-line no-param-reassign
          item.querySelector(_this3.options.selectorLeftNavListItemLink).tabIndex = -1;
        } else {
          // eslint-disable-next-line no-param-reassign
          item.querySelector(_this3.options.selectorLeftNavListItemLink).tabIndex = 0;
        }
      });
    }

    /**
     * The map associating DOM element and spinner instance.
     * @member InteriorLeftNav.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode InteriorLeftNav.create .create()}, or {@linkcode InteriorLeftNav.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode InteriorLeftNav.init .init()} works.
     * @member InteriorLeftNav.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find interior left navs.
     */

  }]);

  return InteriorLeftNav;
}(mixin(createComponent, initComponentBySearch));

InteriorLeftNav.components = new WeakMap();
InteriorLeftNav.options = {
  selectorInit: '[data-interior-left-nav]',
  // Data Attribute selectors
  selectorLeftNavList: '[data-interior-left-nav-list]',
  selectorLeftNavNestedList: '[data-interior-left-nav-nested-list]',
  selectorLeftNavListItem: '[data-interior-left-nav-item]',
  selectorLeftNavListItemLink: '[data-interior-left-nav-item-link]',
  selectorLeftNavNestedListItem: '[data-interior-left-nav-nested-item]',
  selectorLeftNavListItemHasChildren: '[data-interior-left-nav-with-children]',
  selectorLeftNavCollapse: '[data-interior-left-nav-collapse]',
  // CSS Class Selectors
  classActiveLeftNavListItem: 'left-nav-list__item--active',
  classExpandedLeftNavListItem: 'left-nav-list__item--expanded',
  classLeftNavCollapsing: 'bx--interior-left-nav--collapsing',
  classLeftNavCollapsed: 'bx--interior-left-nav--collapsed',
  classLeftNavExpanding: 'bx--interior-left-nav--expanding',
  // Event
  eventBeforeLeftNavToggled: 'left-nav-beingtoggled',
  eventAfterLeftNavToggled: 'left-nav-toggled'
};

var _createClass$21 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$7 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _classCallCheck$22(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$21(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$21(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ProfileSwitcher = function (_mixin) {
  _inherits$21(ProfileSwitcher, _mixin);

  /**
   * Profile Switcher.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a profile switcher.
   * @param {Object} [options] The component options
   * @param {string} [options.selectorProfileSwitcher] The data attribute selector for the profile switcher.
   * @param {string} [options.selectorAccount]
   *   The data attribute selector for the element containing the account name in the profile switcher.
   * @param {string} [options.selectorOrg]
   *   The data attribute selector for the element containing the organization name in the profile switcher.
   * @param {string} [options.selectorSpace]
   *   The data attribute selector for the element containing the space name in the profile switcher.
   * @param {string} [options.selectorAccountDropdown]
   *   The data attribute selector for the dropdown item containing the current account name.
   * @param {string} [options.selectorOrgDropdown]
   *   The data attribute selector for the dropdown item containing the current organization name.
   * @param {string} [options.selectorSpaceDropdown]
   *   The data attribute selector for the dropdown item containing the current space name.
   */
  function ProfileSwitcher(element, options) {
    _classCallCheck$22(this, ProfileSwitcher);

    var _this = _possibleConstructorReturn$21(this, (ProfileSwitcher.__proto__ || Object.getPrototypeOf(ProfileSwitcher)).call(this, element, options));

    _this.hDocumentClick = on(_this.element.ownerDocument, 'click', function (evt) {
      _this.handleDocumentClick(evt);
    });

    _this.element.addEventListener('dropdown-beingselected', function (event) {
      if (event.target.querySelector(_this.options.selectorAccountDropdown) !== null) {
        var linkedIconNode = event.detail.item.querySelector(_this.options.classLinkedIcon);
        _this.element.isLinked = !!linkedIconNode;
        _this.element.linkedIcon = linkedIconNode && linkedIconNode.cloneNode(true);
        var linkedAccountNode = event.detail.item.querySelector(_this.options.selectorAccountSlLinked);
        _this.element.linkedAccount = linkedAccountNode && linkedAccountNode.cloneNode(true);
      }
    });

    var toggleNode = _this.element.querySelector(_this.options.selectorToggle);
    if (toggleNode) {
      toggleNode.addEventListener('keydown', function (event) {
        _this.toggle(event);
      });

      toggleNode.addEventListener('mouseenter', function (event) {
        _this.getLinkedData(event);
        _this.determineSwitcherValues(true);
      });

      toggleNode.addEventListener('mouseleave', function (event) {
        _this.getLinkedData(event);
        _this.determineSwitcherValues(false);
      });
    }

    _this.element.ownerDocument.addEventListener('keyup', function () {
      return _this.handleBlur();
    });
    return _this;
  }

  /**
   * Opens and closes the menu.
   * @param {Event} event The event triggering this method.
   */


  _createClass$21(ProfileSwitcher, [{
    key: 'toggle',
    value: function toggle(event) {
      var isOfSelf = this.element.contains(event.target);
      if (event.which === 13 || event.which === 32) {
        if (isOfSelf) {
          this.element.classList.toggle(this.options.classSwitcherOpen);
        } else if (!isOfSelf && this.element.classList.contains(this.options.classSwitcherOpen)) {
          this.element.classList.remove(this.options.classSwitcherOpen);
        }
      }
    }
  }, {
    key: 'getLinkedData',
    value: function getLinkedData(event) {
      if (event.target.querySelector(this.options.selectorLinkedAccount) !== null) {
        if (event.target.querySelector(this.options.selectorLinkedAccount).textContent.length > 1) {
          this.element.isLinked = true;
        } else {
          this.element.isLinked = false;
        }
      }
    }
  }, {
    key: 'handleBlur',
    value: function handleBlur() {
      if (!this.element.contains(document.activeElement)) {
        this.element.classList.remove(this.options.classSwitcherOpen);
      }
    }

    /**
     * Handles click on the document.
     * Closes the profile switcherwhen document is clicked outside the left navigation or
     * the user clicks the profile switcher while it is open.
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: 'handleDocumentClick',
    value: function handleDocumentClick(evt) {
      var clickTarget = evt.target;
      var isOfSelf = this.element.contains(clickTarget);
      var isToggle = eventMatches(evt, this.options.selectorToggle);
      var isOpen = this.element.classList.contains(this.options.classSwitcherOpen);

      if (isOfSelf) {
        if (isToggle && isOpen) {
          this.element.classList.remove(this.options.classSwitcherOpen);
        } else if (isOpen) {
          this.determineSwitcherValues();
        } else {
          this.element.classList.add(this.options.classSwitcherOpen);
        }
      } else {
        this.element.classList.remove(this.options.classSwitcherOpen);
      }
    }

    /**
     * Handles logic to determine what text to display in profile switcher.
     * If the text is over 25 characters long, truncate and add ellipses.
     * Also adds logic to change the switcher width based on the width of the hovered
     * profile switcher
     * @param {boolean} isHovered boolean value passed by the event listener on bx--toggle.
     */

  }, {
    key: 'determineSwitcherValues',
    value: function determineSwitcherValues(isHovered) {
      var linkedElement = this.element.querySelector(this.options.selectorLinkedAccount);
      var nameElement = this.element.querySelector(this.options.selectorAccount);
      var regionElement = this.element.querySelector(this.options.selectorRegion);
      var orgElement = this.element.querySelector(this.options.selectorOrg);
      var spaceElement = this.element.querySelector(this.options.selectorSpace);
      var menuElement = this.element.querySelector(this.options.selectorMenu);
      var isOpen = this.element.classList.contains(this.options.classSwitcherOpen);

      if (linkedElement) {
        if (this.element.isLinked) {
          if (this.element.linkedAccount) {
            if (linkedElement.textContent.length) {
              linkedElement.querySelector(this.options.selectorAccountSlLinked).textContent = this.element.linkedAccount.textContent;
            } else {
              linkedElement.appendChild(this.element.linkedAccount);
              if (this.element.linkedIcon) {
                linkedElement.appendChild(this.element.linkedIcon);
              }
            }
          }
        } else {
          linkedElement.textContent = '';
        }
      }

      var nameDropdownValue = '';
      if (this.element.querySelector(this.options.selectorAccountDropdown)) {
        if (this.element.isLinked) {
          nameDropdownValue = this.element.querySelector(this.options.selectorAccountLinked).textContent;
        } else {
          nameDropdownValue = this.element.querySelector(this.options.selectorAccountDropdown).textContent;
        }
      }

      var regionDropdownValue = '';
      if (this.element.querySelector(this.options.selectorRegionDropdown)) {
        regionDropdownValue = this.element.querySelector(this.options.selectorRegionDropdown).textContent;
      }

      var orgDropdownValue = '';
      if (this.element.querySelector(this.options.selectorOrgDropdown)) {
        orgDropdownValue = this.element.querySelector(this.options.selectorOrgDropdown).textContent;
      }

      var spaceDropdownValue = '';
      if (this.element.querySelector(this.options.selectorSpaceDropdown)) {
        spaceDropdownValue = this.element.querySelector(this.options.selectorSpaceDropdown).textContent;
      }

      var nameShort = void 0;
      var orgShort = void 0;
      var spaceShort = void 0;

      if (isHovered && !isOpen) {
        if (nameElement) {
          nameElement.textContent = nameDropdownValue;
        }
        if (orgElement) {
          orgElement.textContent = orgDropdownValue;
        }
        if (spaceElement) {
          spaceElement.textContent = spaceDropdownValue;
        }
        if (regionElement) {
          regionElement.textContent = regionDropdownValue;
        }
        if (menuElement) {
          menuElement.style.width = this.element.getBoundingClientRect().width + 'px';
        }
      } else {
        if (nameElement) {
          if (nameDropdownValue.length > 25) {
            nameShort = nameDropdownValue.substr(0, 25) + '...';
            nameElement.textContent = nameShort;
          } else {
            nameElement.textContent = nameDropdownValue;
          }
        }

        if (orgElement) {
          if (orgDropdownValue.length > 25) {
            orgShort = orgDropdownValue.slice(0, 12) + '...' + orgDropdownValue.slice(-13);
            orgElement.textContent = orgShort;
          } else {
            orgElement.textContent = orgDropdownValue;
          }
        }

        if (spaceElement) {
          if (spaceDropdownValue.length > 25) {
            spaceShort = spaceDropdownValue.substr(0, 25) + '...';
            spaceElement.textContent = spaceShort;
          } else {
            spaceElement.textContent = spaceDropdownValue;
          }
        }

        if (regionElement) {
          regionElement.textContent = regionDropdownValue;
        }

        if (menuElement) {
          menuElement.style.width = this.element.getBoundingClientRect().width + 'px';
        }
      }
    }
  }, {
    key: 'release',
    value: function release() {
      if (this.hDocumentClick) {
        this.hDocumentClick = this.hDocumentClick.release();
      }
      _get$7(ProfileSwitcher.prototype.__proto__ || Object.getPrototypeOf(ProfileSwitcher.prototype), 'release', this).call(this);
    }

    /**
     * The component options.
     * @member ProfileSwitcher.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find profile switchers.
     * @property {string} [selectorProfileSwitcher] The data attribute selector for the profile switcher.
     * @property {string} [selectorAccount]
     *   The data attribute selector for the element containing the account name in the profile switcher.
     * @property {string} [selectorOrg]
     *   The data attribute selector for the element containing the organization name in the profile switcher.
     * @property {string} [selectorSpace]
     *   The data attribute selector for the element containing the space name in the profile switcher.
     * @property {string} [selectorAccountDropdown]
     *   The data attribute selector for the dropdown item containing the current account name.
     * @property {string} [selectorOrgDropdown]
     *   The data attribute selector for the dropdown item containing the current organization name.
     * @property {string} [selectorSpaceDropdown]
     *   The data attribute selector for the dropdown item containing the current space name.
     */


    /**
     * The map associating DOM element and profile switcher instance.
     * @member ProfileSwitcher.components
     * @type {WeakMap}
     */

  }]);

  return ProfileSwitcher;
}(mixin(createComponent, initComponentBySearch));

ProfileSwitcher.options = {
  selectorInit: '[data-profile-switcher]',
  // Data Attribute selectors
  selectorProfileSwitcher: '[data-profile-switcher]',
  selectorToggle: '[data-profile-switcher-toggle]',
  selectorMenu: '[data-switcher-menu]',
  selectorLinkedAccount: '[data-switcher-account-sl]',
  selectorAccount: '[data-switcher-account]',
  selectorRegion: '[data-switcher-region]',
  selectorOrg: '[data-switcher-org]',
  selectorSpace: '[data-switcher-space]',
  selectorDropdown: '[data-dropdown]',
  selectorAccountDropdown: '[data-dropdown-account]',
  selectorAccountSlDropdown: '[data-dropdown-account-sl]',
  selectorAccountLinked: '[data-dropdown-account-linked]',
  selectorAccountSlLinked: '[data-dropdown-account-sl-linked]',
  selectorRegionDropdown: '[data-dropdown-region]',
  selectorOrgDropdown: '[data-dropdown-org]',
  selectorSpaceDropdown: '[data-dropdown-space]',
  classSwitcherOpen: 'bx--account-switcher--open',
  classLinkedIcon: '.bx--account-switcher__linked-icon'
};
ProfileSwitcher.components = new WeakMap();

function _classCallCheck$23(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$22(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$22(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Pagination = function (_mixin) {
  _inherits$22(Pagination, _mixin);

  /**
  * Pagination component.
  * @extends CreateComponent
  * @extends InitComponentBySearch
  * @param {HTMLElement} element The element working as a pagination component.
  * @param {Object} [options] The component options.
  * @property {string} [selectorInit] The CSS selector to find pagination components.
  * @property {string} [selectorItemsPerPageInput]
  *   The CSS selector to find the input that determines the number of items per page.
  * @property {string} [selectorPageNumberInput] The CSS selector to find the input that changes the page displayed.
  * @property {string} [selectorPageBackward] The CSS selector to find the button that goes back a page.
  * @property {string} [selectorPageForward] The CSS selector to find the button that goes forward a page.
  * @property {string} [eventItemsPerPage]
  *   The name of the custom event fired when a user changes the number of items per page.
  *   event.detail.value contains the number of items a user wishes to see.
  * @property {string} [eventPageNumber]
  *   The name of the custom event fired when a user inputs a specific page number.
  *   event.detail.value contains the value that the user input.
  * @property {string} [eventPageChange]
  *   The name of the custom event fired when a user goes forward or backward a page.
  *   event.detail.direction contains the direction a user wishes to go.
  */
  function Pagination(element, options) {
    _classCallCheck$23(this, Pagination);

    var _this = _possibleConstructorReturn$22(this, (Pagination.__proto__ || Object.getPrototypeOf(Pagination)).call(this, element, options));

    _this._emitEvent = function (evtName, detail) {
      var event = new CustomEvent('' + evtName, {
        bubbles: true,
        cancelable: true,
        detail: detail
      });

      _this.element.dispatchEvent(event);
    };

    _this.element.addEventListener('click', function (evt) {
      if (evt.target.matches(_this.options.selectorPageBackward)) {
        var detail = {
          initialEvt: evt,
          element: evt.target,
          direction: 'backward'
        };
        _this._emitEvent(_this.options.eventPageChange, detail);
      } else if (evt.target.matches(_this.options.selectorPageForward)) {
        var _detail = {
          initialEvt: evt,
          element: evt.target,
          direction: 'forward'
        };
        _this._emitEvent(_this.options.eventPageChange, _detail);
      }
    });

    _this.element.addEventListener('input', function (evt) {
      if (evt.target.matches(_this.options.selectorItemsPerPageInput)) {
        var detail = {
          initialEvt: evt,
          element: evt.target,
          value: evt.target.value
        };
        _this._emitEvent(_this.options.eventItemsPerPage, detail);
      } else if (evt.target.matches(_this.options.selectorPageNumberInput)) {
        var _detail2 = {
          initialEvt: evt,
          element: evt.target,
          value: evt.target.value
        };
        _this._emitEvent(_this.options.eventPageNumber, _detail2);
      }
    });
    return _this;
  }

  /**
   * Dispatches a custom event
   * @param {String} evtName name of the event to be dispatched.
   * @param {Object} detail contains the original event and any other necessary details.
   */


  /**
   * The map associating DOM element and pagination instance.
   * @type {WeakMap}
   */


  /**
   * The component options.
   * If `options` is specified in the constructor,
   * {@linkcode Pagination.create .create()}, or {@linkcode Pagination.init .init()},
   * properties in this object are overriden for the instance being create and how {@linkcode Pagination.init .init()} works.
   * @property {string} [selectorInit] The CSS selector to find pagination components.
   * @property {string} [selectorItemsPerPageInput] The CSS selector to find the input that determines
   * the number of items per page.
   * @property {string} [selectorPageNumberInput] The CSS selector to find the input that changes the page displayed.
   * @property {string} [selectorPageBackward] The CSS selector to find the button that goes back a page.
   * @property {string} [selectorPageForward] The CSS selector to find the button that goes forward a page.
   * @property {string} [eventItemsPerPage]
   *   The name of the custom event fired when a user changes the number of items per page.
   *   event.detail.value contains the number of items a user wishes to see.
   * @property {string} [eventPageNumber]
   *   The name of the custom event fired when a user inputs a specific page number.
   *   event.detail.value contains the value that the user input.
   * @property {string} [eventPageChange]
   *   The name of the custom event fired when a user goes forward or backward a page.
   *   event.detail.direction contains the direction a user wishes to go.
   */


  return Pagination;
}(mixin(createComponent, initComponentBySearch));

Pagination.components = new WeakMap();
Pagination.options = {
  selectorInit: '[data-pagination]',
  selectorItemsPerPageInput: '[data-items-per-page]',
  selectorPageNumberInput: '[data-page-number-input]',
  selectorPageBackward: '[data-page-backward]',
  selectorPageForward: '[data-page-forward]',
  eventItemsPerPage: 'itemsPerPage',
  eventPageNumber: 'pageNumber',
  eventPageChange: 'pageChange'
};

var _createClass$22 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$12(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$24(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$23(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$23(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Search = function (_mixin) {
  _inherits$23(Search, _mixin);

  /**
   * Search with Options.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as the search component.
   * @param {Object} [options] The component options
   * @property {string} [options.selectorInit]
   *   The selector to find search UIs with options.
   * @property {string} [options.selectorSearchView]
   *   The selector to find the search view icon containers.
   * @property {string} [options.selectorSearchInput]
   *   The selector to find the search input.
   * @property {string} [options.selectorClearIcon]
   *   The selector for the clear icon that clears the search box.
   * @property {string} [options.selectorIconContainer] The data attribute selector for the icon layout container.
   * @property {string} [options.classClearHidden] The class used to hide the clear icon.
   * @property {string} [options.classLayoutHidden] The class used to hide nonselected layout view.
   */
  function Search(element, options) {
    _classCallCheck$24(this, Search);

    var _this = _possibleConstructorReturn$23(this, (Search.__proto__ || Object.getPrototypeOf(Search)).call(this, element, options));

    var closeIcon = _this.element.querySelector(_this.options.selectorClearIcon);
    var input = _this.element.querySelector(_this.options.selectorSearchInput);
    if (!input) {
      throw new Error('Cannot find the search input.');
    }

    if (closeIcon) {
      closeIcon.addEventListener('click', function () {
        svgToggleClass(closeIcon, _this.options.classClearHidden, true);
        input.value = '';
        input.focus();
      });
    }

    _this.element.addEventListener('click', function (evt) {
      var toggleItem = eventMatches(evt, _this.options.selectorIconContainer);
      if (toggleItem) _this.toggleLayout(toggleItem);
    });

    input.addEventListener('input', function (evt) {
      if (closeIcon) _this.showClear(evt.target.value, closeIcon);
    });
    return _this;
  }

  /**
   * Toggles between the grid and list layout.
   * @param {HTMLElement} element The element contining the layout toggle.
   */


  _createClass$22(Search, [{
    key: 'toggleLayout',
    value: function toggleLayout(element) {
      var _this2 = this;

      [].concat(_toConsumableArray$12(element.querySelectorAll(this.options.selectorSearchView))).forEach(function (item) {
        item.classList.toggle(_this2.options.classLayoutHidden);
      });
    }

    /**
     * Toggles the clear icon visibility
     * @param {HTMLElement} input The element serving as the search input.
     * @param {HTMLElement} icon The element serving as close icon.
     */

  }, {
    key: 'showClear',
    value: function showClear(value, icon) {
      svgToggleClass(icon, this.options.classClearHidden, value.length === 0);
    }

    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode Search.create .create()}, or {@linkcode Search.init .init()},
     * properties in this object are overriden for the instance being created
     * and how {@linkcode Search.init .init()} works.
     * @member Search.options
     * @type {Object}
     * @property {string} [options.selectorInit]
     *   The selector to find search UIs with options.
     * @property {string} [options.selectorSearchView]
     *   The selector to find the search view icon containers.
     * @property {string} [options.selectorSearchInput]
     *   The selector to find the search input.
     * @property {string} [options.selectorClearIcon]
     *   The selector for the clear icon that clears the search box.
     * @property {string} [options.selectorIconContainer] The data attribute selector for the icon layout container.
     * @property {string} [options.classClearHidden] The class used to hide the clear icon.
     * @property {string} [options.classLayoutHidden] The class used to hide nonselected layout view.
     */


    /**
     * The map associating DOM element and search instance.
     * @member Search.components
     * @type {WeakMap}
     */

  }]);

  return Search;
}(mixin(createComponent, initComponentBySearch));

Search.options = {
  selectorInit: '[data-search]',
  selectorSearchView: '[data-search-view]',
  selectorSearchInput: '.bx--search-input',
  selectorClearIcon: '.bx--search-close',
  selectorIconContainer: '.bx--search-button[data-search-toggle]',
  classClearHidden: 'bx--search-close--hidden',
  classLayoutHidden: 'bx--search-view--hidden'
};
Search.components = new WeakMap();

var _createClass$23 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$25(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$24(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$24(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Accordion = function (_mixin) {
  _inherits$24(Accordion, _mixin);

  /**
   * Accordion.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as an accordion.
   */
  function Accordion(element, options) {
    _classCallCheck$25(this, Accordion);

    var _this = _possibleConstructorReturn$24(this, (Accordion.__proto__ || Object.getPrototypeOf(Accordion)).call(this, element, options));

    _this.element.addEventListener('click', function (event) {
      var item = eventMatches(event, _this.options.selectorAccordionItem);
      if (item && !eventMatches(event, _this.options.selectorAccordionContent)) {
        item.classList.toggle(_this.options.classActive);
      }
    });

    _this.element.addEventListener('keypress', function (event) {
      var item = eventMatches(event, _this.options.selectorAccordionItem);
      if (item && !eventMatches(event, _this.options.selectorAccordionContent)) {
        _this._handleKeypress(event);
      }
    });
    return _this;
  }

  /**
   * Handles toggling of active state of accordion via keyboard
   * @param {Event} event The event triggering this method.
   */


  _createClass$23(Accordion, [{
    key: '_handleKeypress',
    value: function _handleKeypress(event) {
      if (event.which === 13 || event.which === 32) {
        event.target.classList.toggle(this.options.classActive);
      }
    }

    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode NumberInput.create .create()}, or {@linkcode NumberInput.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode NumberInput.init .init()} works.
     * @property {string} selectorInit The CSS selector to find accordion UIs.
     */


    /**
     * The map associating DOM element and accordion UI instance.
     * @type {WeakMap}
     */

  }]);

  return Accordion;
}(mixin(createComponent, initComponentBySearch));

Accordion.options = {
  selectorInit: '[data-accordion]',
  selectorAccordionItem: '.bx--accordion__item',
  selectorAccordionContent: '.bx--accordion__content',
  classActive: 'bx--accordion__item--active'
};
Accordion.components = new WeakMap();

var _createClass$24 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$26(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$25(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$25(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var CopyButton = function (_mixin) {
  _inherits$25(CopyButton, _mixin);

  /**
   * CopyBtn UI.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a copy button UI.
   */
  function CopyButton(element, options) {
    _classCallCheck$26(this, CopyButton);

    var _this = _possibleConstructorReturn$25(this, (CopyButton.__proto__ || Object.getPrototypeOf(CopyButton)).call(this, element, options));

    _this.element.addEventListener('click', function () {
      return _this.handleClick();
    });
    return _this;
  }

  /**
   * Show the feedback tooltip on click. Hide the feedback tooltip after specified timeout value.
   */


  _createClass$24(CopyButton, [{
    key: 'handleClick',
    value: function handleClick() {
      var _this2 = this;

      var feedback = this.element.querySelector(this.options.feedbackTooltip);
      if (feedback) {
        feedback.classList.add(this.options.classShowFeedback);
        setTimeout(function () {
          feedback.classList.remove(_this2.options.classShowFeedback);
        }, this.options.timeoutValue);
      }
    }

    /**
     * The map associating DOM element and copy button UI instance.
     * @member CopyBtn.components
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor, {@linkcode CopyBtn.create .create()}, or {@linkcode CopyBtn.init .init()},
     * properties in this object are overriden for the instance being create and how {@linkcode CopyBtn.init .init()} works.
     * @member CopyBtn.options
     * @type {Object}
     * @property {string} selectorInit The data attribute to find copy button UIs.
     * @property {string} feedbackTooltip The data attribute to find feedback tooltip.
     * @property {string} classShowFeedback The CSS selector for showing the feedback tooltip.
     * @property {number} timeoutValue The specified timeout value before the feedback tooltip is hidden.
     */

  }]);

  return CopyButton;
}(mixin(createComponent, initComponentBySearch));

CopyButton.components = new WeakMap();
CopyButton.options = {
  selectorInit: '[data-copy-btn]',
  feedbackTooltip: '[data-feedback]',
  classShowFeedback: 'bx--btn--copy__feedback--displayed',
  timeoutValue: 2000
};

var _createClass$25 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$27(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$26(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$26(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Notification = function (_mixin) {
  _inherits$26(Notification, _mixin);

  /**
   * InlineNotification.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as a InlineNotification.
   */
  function Notification(element, options) {
    _classCallCheck$27(this, Notification);

    var _this = _possibleConstructorReturn$26(this, (Notification.__proto__ || Object.getPrototypeOf(Notification)).call(this, element, options));

    _this._changeState = function (state, callback) {
      if (state === 'delete-notification') {
        _this.element.parentNode.removeChild(_this.element);
        _this.release();
      }
      callback();
    };

    _this.button = element.querySelector(_this.options.selectorButton);
    if (_this.button) {
      _this.button.addEventListener('click', function (evt) {
        if (evt.currentTarget === _this.button) {
          _this.remove();
        }
      });
    }
    return _this;
  }

  _createClass$25(Notification, [{
    key: 'remove',
    value: function remove() {
      this.changeState('delete-notification');
    }

    /**
     * The map associating DOM element and accordion UI instance.
     * @type {WeakMap}
     */


    /**
     * The component options.
     * @property {string} selectorInit The CSS selector to find InlineNotification.
     * @property {string} selectorButton The CSS selector to find close button.
     */

  }]);

  return Notification;
}(mixin(createComponent, initComponentBySearch, eventedState));

Notification.components = new WeakMap();
Notification.options = {
  selectorInit: '[data-notification]',
  selectorButton: '[data-notification-btn]',
  eventBeforeDeleteNotification: 'notification-before-delete',
  eventAfterDeleteNotification: 'notification-after-delete'
};

var _createClass$26 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _get$8 = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

function _toConsumableArray$13(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$28(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$27(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$27(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Toolbar = function (_mixin) {
  _inherits$27(Toolbar, _mixin);

  /**
   * Toolbar.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element working as an toolbar.
   */
  function Toolbar(element, options) {
    _classCallCheck$28(this, Toolbar);

    var _this = _possibleConstructorReturn$27(this, (Toolbar.__proto__ || Object.getPrototypeOf(Toolbar)).call(this, element, options));

    if (!_this.element.dataset.tableTarget) {
      console.warn('There is no table bound to this toolbar!'); // eslint-disable-line no-console
    } else {
      var boundTable = _this.element.ownerDocument.querySelector(_this.element.dataset.tableTarget);
      var rowHeightBtns = _this.element.querySelector(_this.options.selectorRowHeight);
      if (rowHeightBtns) {
        rowHeightBtns.addEventListener('click', function (event) {
          _this._handleRowHeightChange(event, boundTable);
        });
        // [...this.element.querySelectorAll(this.options.selectorRowHeight)].forEach((item) => {
        //   item.addEventListener('click', (event) => { this._handleRowHeightChange(event, boundTable); });
        // });
      }
    }

    _this.hDocumentKeyDown = on(_this.element.ownerDocument, 'keydown', function (evt) {
      _this._handleKeyDown(evt);
    });

    _this.hDocumentClick = on(_this.element.ownerDocument, 'click', function (evt) {
      _this._handleDocumentClick(evt);
    });
    return _this;
  }

  /**
   * Handles toggling of active state of the toolbar search input
   * @param {Event} event The event triggering this method.
   */


  _createClass$26(Toolbar, [{
    key: '_handleDocumentClick',
    value: function _handleDocumentClick(event) {
      var _this2 = this;

      var searchInput = eventMatches(event, this.options.selectorSearch);
      var isOfSelfSearchInput = searchInput && this.element.contains(searchInput);

      if (isOfSelfSearchInput) {
        var shouldBeOpen = isOfSelfSearchInput && !this.element.classList.contains(this.options.classSearchActive);
        searchInput.classList.toggle(this.options.classSearchActive, shouldBeOpen);
        if (shouldBeOpen) {
          searchInput.querySelector('input').focus();
        }
      }

      var targetComponentElement = eventMatches(event, this.options.selectorInit);
      [].concat(_toConsumableArray$13(this.element.ownerDocument.querySelectorAll(this.options.selectorSearch))).forEach(function (item) {
        if (!targetComponentElement || !targetComponentElement.contains(item)) {
          item.classList.remove(_this2.options.classSearchActive);
        }
      });
    }

    /**
     * Handles toggling of active state of the toolbar search input via the keyboard
     * @param {Event} event The event triggering this method.
     */

  }, {
    key: '_handleKeyDown',
    value: function _handleKeyDown(event) {
      var searchInput = eventMatches(event, this.options.selectorSearch);
      var isOfSelf = this.element.contains(event.target);
      var shouldBeOpen = isOfSelf && !this.element.classList.contains(this.options.classSearchActive);

      if (searchInput) {
        if ((event.which === 13 || event.which === 32) && !shouldBeOpen) {
          searchInput.classList.add(this.options.classSearchActive);
        }

        if (event.which === 27) {
          searchInput.classList.remove(this.options.classSearchActive);
        }
      }
    }

    /**
     * Handles toggling of the row height of the associated table
     * @param {Event} event The event triggering this method.
     * @param {HTMLElement} boundTable The table associated with the toolbar.
     */

  }, {
    key: '_handleRowHeightChange',
    value: function _handleRowHeightChange(event, boundTable) {
      var value = event.currentTarget.querySelector('input:checked').value;

      if (value === 'tall') {
        boundTable.classList.add(this.options.classTallRows);
      } else {
        boundTable.classList.remove(this.options.classTallRows);
      }
    }
  }, {
    key: 'release',
    value: function release() {
      if (this.hDocumentClick) {
        this.hDocumentClick = this.hDocumentClick.release();
      }
      if (this.hDocumentKeyPress) {
        this.hDocumentKeyPress = this.hDocumentKeyPress.release();
      }
      _get$8(Toolbar.prototype.__proto__ || Object.getPrototypeOf(Toolbar.prototype), 'release', this).call(this);
    }

    /**
     * The map associating DOM element and Toolbar UI instance.
     * @type {WeakMap}
     */


    /**
     * The component options.
     * If `options` is specified in the constructor,
     * properties in this object are overriden for the instance being created.
     * @property {string} selectorInit The CSS selector to find toolbar instances.
     * @property {string} selectorSearch The CSS selector to find search inputs in a toolbar.
     * @property {string} selectorRowHeight The CSS selector to find the row height inputs in a toolbar.
     * @property {string} classTallRows The CSS class for making table rows into tall rows.
     * @property {string} classSearchActive The CSS class the active state of the search input.
     */

  }]);

  return Toolbar;
}(mixin(createComponent, initComponentBySearch));

Toolbar.components = new WeakMap();
Toolbar.options = {
  selectorInit: '[data-toolbar]',
  selectorSearch: '[data-toolbar-search]',
  selectorRowHeight: '[data-row-height]',
  classTallRows: 'bx--responsive-table--tall',
  classSearchActive: 'bx--toolbar-search--active'
};

var _createClass$27 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck$29(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$28(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$28(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Tooltip = function (_mixin) {
  _inherits$28(Tooltip, _mixin);

  /**
   * Tooltip.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   */
  function Tooltip(element, options) {
    _classCallCheck$29(this, Tooltip);

    var _this = _possibleConstructorReturn$28(this, (Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call(this, element, options));

    ['mouseover', 'mouseout', 'focus', 'blur'].forEach(function (name) {
      _this.element.addEventListener(name, function (event) {
        _this._handleHover(event);
      });
    });
    return _this;
  }

  /**
   * A method called when this widget is created upon events.
   * @param {Event} event The event triggering the creation.
   */


  _createClass$27(Tooltip, [{
    key: 'createdByEvent',
    value: function createdByEvent(event) {
      this._handleHover(event);
    }

    /**
     * Changes the shown/hidden state.
     * @param {string} state The new state.
     * @param {Object} detail The detail of the event trigging this action.
     * @param {Function} callback Callback called when change in state completes.
     // */

  }, {
    key: 'changeState',
    value: function changeState(state, detail, callback) {
      if (!this.tooltip) {
        var tooltip = this.element.ownerDocument.querySelector(this.element.getAttribute(this.options.attribTooltipTarget));
        if (!tooltip) {
          throw new Error('Cannot find the target tooltip.');
        }

        // Lazily create a component instance for tooltip
        this.tooltip = FloatingMenu.create(tooltip, {
          refNode: this.element,
          classShown: this.options.classShown,
          offset: this.options.objMenuOffset
        });
        this.children.push(this.tooltip);
      }

      // Delegates the action of changing state to the tooltip.
      // (And thus the before/after shown/hidden events are fired from the tooltip)
      this.tooltip.changeState(state, Object.assign(detail, { delegatorNode: this.element }), callback);
    }

    /**
     * Handles hover/focus events.
     * @param {Event} event The event.
     * @private
     */

  }, {
    key: '_handleHover',
    value: function _handleHover(event) {
      var state = {
        mouseover: 'shown',
        mouseout: 'hidden',
        focus: 'shown',
        blur: 'hidden'
      }[event.type];
      this.changeState(state, getLaunchingDetails(event));
    }
  }]);

  return Tooltip;
}(mixin(createComponent, initComponentByEvent, exports$1));

Tooltip.components = new WeakMap();
Tooltip.options = {
  selectorInit: '[data-tooltip-trigger]',
  classShown: 'bx--tooltip--shown',
  attribTooltipTarget: 'data-tooltip-target',
  objMenuOffset: { top: 10, left: 0 },
  initEventNames: ['mouseover', 'focus']
};

var _createClass$28 = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _toConsumableArray$14(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck$30(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn$29(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits$29(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ProgressIndicator = function (_mixin) {
  _inherits$29(ProgressIndicator, _mixin);

  /**
   * ProgressIndicator.
   * @extends CreateComponent
   * @extends InitComponentBySearch
   * @param {HTMLElement} element The element representing the ProgressIndicator.
   * @param {Object} [state] The component state.
   * @param {Object} [state.currentIndex] The current step index.
   * @param {Object} [state.totalSteps] Total number of steps.
   * @param {Object} [options] The component options.
   * @property {string} [options.selectorStepElement] The CSS selector to find step elements.
   * @property {string} [options.selectorCurrent] The CSS selector to find the current step element.
   * @property {string} [options.selectorIncomplete] The CSS class to find incomplete step elements.
   * @property {string} [options.selectorComplete] The CSS selector to find completed step elements.
   * @property {string} [options.classStep] The className for a step element.
   * @property {string} [options.classComplete] The className for a completed step element.
   * @property {string} [options.classCurrent] The className for the current step element.
   * @property {string} [options.classIncomplete] The className for a incomplete step element.
   */
  function ProgressIndicator(element, options) {
    _classCallCheck$30(this, ProgressIndicator);

    var _this = _possibleConstructorReturn$29(this, (ProgressIndicator.__proto__ || Object.getPrototypeOf(ProgressIndicator)).call(this, element, options));

    _this.state = {
      currentIndex: _this.getCurrent().index,
      totalSteps: _this.getSteps().length
    };
    return _this;
  }

  /**
   * Returns all steps with details about element and index.
   */


  _createClass$28(ProgressIndicator, [{
    key: 'getSteps',
    value: function getSteps() {
      return [].concat(_toConsumableArray$14(this.element.querySelectorAll(this.options.selectorStepElement))).map(function (element, index) {
        return {
          element: element,
          index: index
        };
      });
    }

    /**
     * Returns current step; gives detail about element and index.
     */

  }, {
    key: 'getCurrent',
    value: function getCurrent() {
      var currentEl = this.element.querySelector(this.options.selectorCurrent);
      return this.getSteps().filter(function (step) {
        return step.element === currentEl;
      })[0];
    }

    /**
     * Sets the current step.
     * * @param {Number} new step index or use default in `this.state.currentIndex`.
     */

  }, {
    key: 'setCurrent',
    value: function setCurrent() {
      var _this2 = this;

      var newCurrentStep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentIndex;

      var changed = false;

      if (newCurrentStep !== this.state.currentIndex) {
        this.state.currentIndex = newCurrentStep;
        changed = true;
      }

      if (changed) {
        this.getSteps().forEach(function (step) {
          if (step.index < newCurrentStep) {
            _this2._updateStep({
              element: step.element,
              className: _this2.options.classComplete,
              html: _this2._getSVGComplete()
            });
          }

          if (step.index === newCurrentStep) {
            _this2._updateStep({
              element: step.element,
              className: _this2.options.classCurrent,
              html: _this2._getCurrentSVG()
            });
          }

          if (step.index > newCurrentStep) {
            _this2._updateStep({
              element: step.element,
              className: _this2.options.classIncomplete,
              html: _this2._getIncompleteSVG()
            });
          }
        });
      }
    }

    /**
     * Update step with correct inline SVG and className
     * @param {Object} args
     * @param {Object} [args.element] target element
     * @param {Object} [args.className] new className
     * @param {Object} [args.html] new inline SVG to insert
     */

  }, {
    key: '_updateStep',
    value: function _updateStep(args) {
      var element = args.element,
          className = args.className,
          html = args.html;


      if (element.firstElementChild) {
        element.removeChild(element.firstElementChild);
      }

      if (!element.classList.contains(className)) {
        element.setAttribute('class', this.options.classStep);
        element.classList.add(className);
      }

      element.insertAdjacentHTML('afterbegin', html);
    }

    /**
     * Returns HTML string for an SVG used to represent a compelted step (checkmark)
     */

  }, {
    key: '_getSVGComplete',
    value: function _getSVGComplete() {
      return '<svg width="24px" height="24px" viewBox="0 0 24 24">\n        <circle cx="12" cy="12" r="12"></circle>\n        <polygon points="10.3 13.6 7.7 11 6.3 12.4 10.3 16.4 17.8 9 16.4 7.6"></polygon>\n      </svg>';
    }

    /**
     * Returns HTML string for an SVG used to represent current step (circles, like a radio button, but not.)
     */

  }, {
    key: '_getCurrentSVG',
    value: function _getCurrentSVG() {
      return '<svg>\n        <circle cx="12" cy="12" r="12"></circle>\n        <circle cx="12" cy="12" r="6"></circle>\n      </svg>';
    }

    /**
     * Returns HTML string for an SVG used to represent incomple step (grey empty circle)
     */

  }, {
    key: '_getIncompleteSVG',
    value: function _getIncompleteSVG() {
      return '<svg>\n        <circle cx="12" cy="12" r="12"></circle>\n      </svg>';
    }

    /**
     * The component options.
     * If `options` is specified in the constructor,
     * {@linkcode ProgressIndicator.create .create()}, or {@linkcode ProgressIndicator.init .init()},
     * properties in this object are overriden for the instance being created.
     * @member ProgressIndicator.options
     * @type {Object}
     * @property {string} selectorInit The CSS selector to find content switcher button set.
     * @property {string} [selectorStepElement] The CSS selector to find step elements.
     * @property {string} [selectorCurrent] The CSS selector to find the current step element.
     * @property {string} [selectorIncomplete] The CSS class to find incomplete step elements.
     * @property {string} [selectorComplete] The CSS selector to find completed step elements.
     * @property {string} [classStep] The className for a step element.
     * @property {string} [classComplete] The className for a completed step element.
     * @property {string} [classCurrent] The className for the current step element.
     * @property {string} [classIncomplete] The className for a incomplete step element.
     */

  }]);

  return ProgressIndicator;
}(mixin(createComponent, initComponentBySearch));

ProgressIndicator.components = new WeakMap();
ProgressIndicator.options = {
  selectorInit: '[data-progress]',
  selectorStepElement: '.bx--progress-step',
  selectorCurrent: '.bx--progress-step--current',
  selectorIncomplete: '.bx--progress-step--incomplete',
  selectorComplete: '.bx--progress-step--complete',
  classStep: 'bx--progress-step',
  classComplete: 'bx--progress-step--complete',
  classCurrent: 'bx--progress-step--current',
  classIncomplete: 'bx--progress-step--incomplete'
};

// ====================//
// Imports and Exports //
// ====================//

// Base Elements & Components
// -------------
// - JavaScript classes for use with components and base-elements.
// - The following statements import classes from actual locations to
//   be consumed from this file instead of their actual locations.
var settings = {};

/**
 * Instantiates components automatically
 * by searching for elements with `data-component-name` (e.g. `data-loading`) attribute
 * or upon DOM events (e.g. clicking) on such elements.
 * See each components' static `.init()` methods for details.
 *
 *
 * @private
 */

var init = function init() {
  if (!settings.disableAutoInit) {
    initCheckbox();
    FabButton.init();
    FileUploader.init();
    ContentSwitcher.init();
    Tab.init();
    OverflowMenu.init();
    Modal.init();
    Loading.init();
    Dropdown.init();
    Card.init();
    NumberInput.init();
    DataTable.init();
    DetailPageHeader.init();
    LeftNav.init();
    InteriorLeftNav.init();
    ProfileSwitcher.init();
    Pagination.init();
    Search.init();
    Accordion.init();
    CopyButton.init();
    Notification.init();
    Toolbar.init();
    Tooltip.init();
    ProgressIndicator.init();
    // Floating menu instances are created by Tooltip, etc. and thus not for automatic instantiation
  }
};

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  // DOMContentLoaded has been fired already
  // Let consumer have chance to see if it wants automatic instantiation disabled, and then run automatic instantiation otherwise
  setTimeout(init, 0);
}

exports.settings = settings;
exports.initCheckbox = initCheckbox;
exports.FabButton = FabButton;
exports.FileUploader = FileUploader;
exports.ContentSwitcher = ContentSwitcher;
exports.Tab = Tab;
exports.OverflowMenu = OverflowMenu;
exports.Modal = Modal;
exports.LeftNav = LeftNav;
exports.Loading = Loading;
exports.Dropdown = Dropdown;
exports.Card = Card;
exports.NumberInput = NumberInput;
exports.DataTable = DataTable;
exports.DetailPageHeader = DetailPageHeader;
exports.Search = Search;
exports.ProfileSwitcher = ProfileSwitcher;
exports.Pagination = Pagination;
exports.Accordion = Accordion;
exports.InteriorLeftNav = InteriorLeftNav;
exports.Notification = Notification;
exports.Toolbar = Toolbar;
exports.Tooltip = Tooltip;
exports.ProgressIndicator = ProgressIndicator;
exports.FloatingMenu = FloatingMenu;
exports.CopyButton = CopyButton;

}((this.CarbonComponents = this.CarbonComponents || {})));